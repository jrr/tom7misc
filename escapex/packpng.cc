// TODO: This is headless; convert to just use ImageRGBA.

#include "../cc-lib/image.h"
#include "../cc-lib/util.h"
#include "../cc-lib/base/stringprintf.h"

#include <iostream>
#include <fstream>
#include <memory>
#include <cstring>

using namespace std;

// #define BACKCOLOR 0x33, 0x88, 0x33, 0xAA
#define BACKCOLOR 0x338833AA

/* smaller growrate gives slightly better output,
   with substantially worse performance */
#define GROWRATE 4

struct UsedMap {
  /* PERF could use less memory with a bit mask,
     but this program is run off-line, so that
     seems pretty pointless */
  char *arr;
  int w, h;

  UsedMap(int ww, int hh) : w(ww), h(hh) {
    arr = (char*)malloc(ww * hh * sizeof(char));
    memset(arr, 0, ww * hh * sizeof (char));
  }

  /* new areas are unused */
  void resize(int ww, int hh) {
    char *na = (char*)malloc(ww * hh * sizeof (char));

    /* start unused */
    memset(na, 0, ww * hh * sizeof (char));

    /* copy old used */
    for (int xx = 0; xx < w; xx++) {
      for (int yy = 0; yy < h; yy++) {
        if (used(xx, yy) && xx < ww && yy < hh) {
          na[yy * ww + xx] = 1;
        }
      }
    }

    free(arr);
    arr = na;
    w = ww;
    h = hh;
  }

  bool used(int x, int y) {
    return arr[x + y * w];
  }

  bool usedrange(int x, int y, int ww, int hh) {
    for (int yy = 0; yy < hh; yy++) {
      for (int xx = 0; xx < ww; xx++) {
        if (used(x + xx, y + yy)) return true;
      }
    }
    return false;
  }

  void use(int x, int y) {
    arr[x + y * w] = 1;
  }

  void userange(int x, int y, int ww, int hh) {
    for (int yy = 0; yy < hh; yy++) {
      for (int xx = 0; xx < ww; xx++) {
        use(x + xx, y + yy);
      }
    }
  }

  ~UsedMap() {
    free(arr);
  }
};

static std::pair<int, int> FitImage(ImageRGBA &packed, UsedMap *um,
                                    int w, int h) {
  for (;;) {
    for (int yy = 0; yy <= um->h - h; yy++) {
      for (int xx = 0; xx <= um->w - w; xx++) {
        if (!um->usedrange(xx, yy, w, h)) {
          um->userange(xx, yy, w, h);
          return make_pair(xx, yy);
        }
      }
    }

    /* didn't fit. expand to make the image more square. */
    /* PERF insane */
    int nw = um->w, nh = um->h;

    /* minimum sane sizes */
    if (um->w < w) {
      nw = w;
    } else if (um->h < h) {
      nh = h;
    } else if (um->w <= um->h) {
      nw = um->w + GROWRATE;
    } else {
      nh = um->h + GROWRATE;
    }

    um->resize(nw, nh);
    packed = packed.Crop32(0, 0, nw, nh, BACKCOLOR);

    printf("resized to %dx%d\n", nw, nh);
  }
}


int main(int argc, char **argv) {

  // XXX probably not useful for this app?
  /* change to location of binary, so that we can find the
     images needed. */
  if (argc > 0) {
    string wd = Util::pathof(argv[0]);
    Util::changedir(wd);
  }

  if (argc != 3) {
    printf("\n"
           "Usage: packpng description.pack basename\n");
    printf("Creates a packed PNG graphic from each of the files in\n"
           "description.pack. Produces:\n"
           "   basename.png    (graphics)\n"
           "   basename_defs.h (defines the members as Basename::pic)\n"
           "   basename_syms.h (just the symbols, comma-separated)\n"
           "   basename_copy.h (copies the surfaces from packed ImageRGBA)\n"
           "\n"
           "See packpng.cc for details.\n\n");
    return 1;
  }

  string descname = argv[1];
  string basename = argv[2];
  if (basename.empty() || !(basename[0] >= 'a' && basename[0] <= 'z')) {
    printf("Basename must start with a lowercase letter!\n");
    return 1;
  }

  printf("Packpng %s %s\n", descname.c_str(), basename.c_str());

  // XXX get this from the pack file?
  string classname = basename;
  // Make its first letter uppercase.
  classname[0] &= ~32;


  /* XXX we should make this part much smarter once
     we have a lot of animation frames or graphics of
     different sizes. The problem is probably NP hard
     in general but we can still do a better job with
     some greedy packing algorithm (keep a bit mask of
     'used' areas of the graphic) */

  /* now a single pass, resizing the destination image
     as needed. */

  ImageRGBA packed(1, 1);
  packed.Clear32(BACKCOLOR);
  std::unique_ptr<UsedMap> um(new UsedMap{1, 1});

  string name, file;

  /* now draw 'em */

  string defname  = basename + "_defs.h";
  string decname  = basename + "_decs.h";
  string loadname = basename + "_load.h";
  FILE *defs = fopen(defname.c_str(), "w");
  FILE *decs = fopen(decname.c_str(), "w");
  FILE *load = fopen(loadname.c_str(), "w");
  if (!(defs && decs && load)) {
    printf("Can't open output files.\n");
    return -1;
  }

  /* load needs some prelude */
  fprintf(load,
          "/* Generated by packpng from %s. DO NOT EDIT */\n"
          "{\n"
          "  SDL_Surface *all = sdlutil::LoadImageFile(DATADIR \"%s.png\");\n"
          "  if (!all) return false;\n"
          "  SDL_SetAlpha(all, 0, 255);\n"
          "  SDL_Rect r;\n",
          descname.c_str(),
          basename.c_str());

  fprintf(defs,
          "/* Generated by packpng from %s. DO NOT EDIT */\n",
          descname.c_str());

  fprintf(decs,
          "/* Generated by packpng from %s. DO NOT EDIT */\n",
          descname.c_str());

  // x, y, w, h
  map<string, std::tuple<int, int, int, int>> all_symbols;
  {
    ifstream desc(descname.c_str());
    while (desc >> name >> file) {
      std::unique_ptr<ImageRGBA> pic(ImageRGBA::Load(file));

      if (!pic.get()) {
        printf("Packpng error! Can't open image file '%s'\n",
               file.c_str());
        exit(-1);
      }

      /* find a place where it will fit. */
      {
        const auto [x, y] =
          FitImage(packed, um.get(), pic->Width(), pic->Height());

        packed.CopyImage(x, y, *pic);

        /* now print info to files */
        fprintf(defs, "static SDL_Surface *%s;\n", name.c_str());
        fprintf(decs, "SDL_Surface *%s::%s;\n",
                classname.c_str(), name.c_str());

        fprintf(load,
                "\n"
                "  r.x = %d;\n"
                "  r.y = %d;\n"
                "  r.w = %d;\n"
                "  r.h = %d;\n"
                "  %s = sdlutil::makesurface(r.w, r.h);\n"
                "  if (!%s) return false;\n"
                "  SDL_BlitSurface(all, &r, %s, 0);\n",
                x, y, pic->Width(), pic->Height(), name.c_str(),
                name.c_str(), name.c_str());

        printf("%s at %d/%d\n", name.c_str(), x, y);

        if (all_symbols.find(name) != all_symbols.end()) {
          fprintf(stderr, "%s appeared more than once\n", name.c_str());
          return -1;
        }
        all_symbols[name] = make_tuple(x, y, pic->Width(), pic->Height());
      }
    }
  }

  /* postlude for load */
  fprintf(load,
          "\n\n"
          "  SDL_FreeSurface(all);\n"
          "}\n");

  fclose(load);
  fclose(defs);
  fclose(decs);

  // New (2021) via graphics.h.

  
  // This is just a comma-separated list of the symbols.
  // Can be used like:
  //   using SDL_SurfacePtr = SDL_Surface *;
  //   SDL_SurfacePtr
  //   #include "animation_syms.h"
  //   ;
  vector<string> syms;
  for (const auto &[sym, pos_] : all_symbols) syms.push_back(sym);
  {
    string syms_contents = 
      StringPrintf("/* Generated by packpng from %s. DO NOT EDIT */\n",
                   descname.c_str());
    syms_contents += Util::Join(syms, ", ");
    Util::WriteFile(StringPrintf("%s_syms.h", basename.c_str()),
                    syms_contents);
  }

  {
    string init_contents = 
      StringPrintf("/* Generated by packpng from %s. DO NOT EDIT */\n",
                   descname.c_str());
    for (const auto &[sym, pos] : all_symbols) {
      const auto [x, y, w, h] = pos;
      StringAppendF(&init_contents,
                    "%s = all.Crop32(%d, %d, %d, %d);\n",
                    sym.c_str(), x, y, w, h);
    }
    Util::WriteFile(StringPrintf("%s_init.h", basename.c_str()),
                    init_contents);
  }

  {
    string copy_contents =
      StringPrintf("/* Generated by packpng from %s. DO NOT EDIT */\n",
                   descname.c_str());

    for (const auto &[sym, pos_] : all_symbols) {
      StringAppendF(&copy_contents,
                    "%s = sdlutil::FromRGBA(graphics.%s);\n"
                    "if (%s == nullptr) return false;\n",
                    sym.c_str(), sym.c_str(),
                    sym.c_str());
    }
    Util::WriteFile(StringPrintf("%s_copy.h", basename.c_str()),
                    copy_contents);
  }
  
  printf("Saving...\n");
  fflush(stdout);

  const string pngfile = basename + ".png";
  if (!packed.Save(pngfile)) {
    printf("Couldn't write output PNG to %s.\n", pngfile.c_str());
    return -1;
  }

  printf("Done!\n");

  return 0;
}
