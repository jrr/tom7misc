
// Note: In guitar.cc, this file is assembled from guitar-head.cc,
// guitar-tail.cc, and some data generated by gencc.cc. Don't edit
// guitar.cc directly.

// Normalize the guitar chord name if possible.
// Sharps/flats on the base chord are rewritten to one of
// C#, Eb, F#, Ab, Bb.
static string NormalizeBase(string s) {
  if (Util::StartsWith(s, "Db")) {
    s[0] = 'C';
    s[1] = '#';
  } else if (Util::StartsWith(s, "D#")) {
    s[0] = 'E';
    s[1] = 'b';
  } else if (Util::StartsWith(s, "Gb")) {
    s[0] = 'F';
    s[1] = '#';
  } else if (Util::StartsWith(s, "G#")) {
    s[0] = 'A';
    s[1] = 'b';
  } else if (Util::StartsWith(s, "A#")) {
    s[0] = 'B';
    s[1] = 'b';
  }
  return s;
}

static string NormalizeSuffix(const string &s) {
  if (s == "major" || s == "maj") return "";
  if (s == "minor" || s == "min") return "m";
  return s;
}

int Guitar::BaseNum(string_view base) {
  for (int i = 0; i < Guitar::NUM_BASES; i++) {
    if (Guitar::BASES[i] == base) return i;
  }
  return -1;
}

int Guitar::SuffixNum(string_view suffix) {
  for (int i = 0; i < Guitar::NUM_SUFFIXES; i++) {
    if (Guitar::SUFFIXES[i] == suffix) return i;
  }
  return -1;
}

std::optional<Guitar::Chord> Guitar::Parse(std::string_view sv) {
  string s = NormalizeBase((string)sv);

  // Longer matches have to come first here, since
  // we use a totally greedy strategy!
  for (string_view pfx : { "C#"sv, "C"sv, "D"sv, "Eb"sv,
	"E"sv, "F#"sv, "F"sv, "G"sv, "Ab"sv, "A"sv, "Bb"sv, "B"sv }) {
    if (Util::TryStripPrefix(pfx, &s)) {
      // Matched.
      const int base_num = BaseNum(pfx);
      s = NormalizeSuffix(s);
      const int suffix_num = SuffixNum(s);
      // Invalid. (Note: Shouldn't continue looping since we've modified s.)
      if (base_num < 0 || suffix_num < 0) return {};
      const Chord c = (base_num << 8) | suffix_num;
      return {c};
    }
  }
  
  // No match for base.
  return {};  
}

// int8_t packed into lowest 6 bytes.
using PackedFingering = uint64_t;
static constexpr Guitar::Fingering Unpack(PackedFingering pf) {
  return make_tuple((int)(int8_t)(255 & (pf >> (5 * 8))),
		    (int)(int8_t)(255 & (pf >> (4 * 8))),
		    (int)(int8_t)(255 & (pf >> (3 * 8))),
		    (int)(int8_t)(255 & (pf >> (2 * 8))),
		    (int)(int8_t)(255 & (pf >> (1 * 8))),
		    (int)(int8_t)(255 & (pf >> (0 * 8))));
}

static constexpr PackedFingering Pack(Guitar::Fingering f) {
  return
    ((255 & (uint64_t)(int8_t)(std::get<0>(f))) << (5 * 8)) |
    ((255 & (uint64_t)(int8_t)(std::get<1>(f))) << (4 * 8)) |
    ((255 & (uint64_t)(int8_t)(std::get<2>(f))) << (3 * 8)) |
    ((255 & (uint64_t)(int8_t)(std::get<3>(f))) << (2 * 8)) |
    ((255 & (uint64_t)(int8_t)(std::get<4>(f))) << (1 * 8)) |
    ((255 & (uint64_t)(int8_t)(std::get<5>(f))) << (0 * 8));
}

// Sanity check the above for -1 especially.
static_assert(Unpack(Pack(make_tuple(-1, 3, 2, -1, 1, 0))) ==
	      make_tuple(-1, 3, 2, -1, 1, 0));

namespace {
// Singleton parsed database. Depends on DATA symbol generated by
// gencc.
struct DB {
  DB() {
    data.resize(Guitar::NUM_BASES);
    int idx = 0;
    auto GetNum = [&idx]() { return CharNum(DATA[idx++]); };
    const int bases_in_data = GetNum();
    CHECK_EQ(bases_in_data, Guitar::NUM_BASES) << "Expected to be dense.";
    for (int b = 0; b < Guitar::NUM_BASES; b++) {
      // Not guaranteed to be in the same order.
      // This will be the index into the vector.
      const int base = GetNum();
      std::unordered_map<int, vector<PackedFingering>> &base_row = data[base];
      
      const int nsuf = GetNum();
      for (int s = 0; s < nsuf; s++) {
	// Suffix code (key into map).
	const int suffix = GetNum();
	vector<PackedFingering> &fingerings = base_row[suffix];

	// Number of fingerings.
	const int nfing = GetNum();
	for (int f = 0; f < nfing; f++) {
	  // Each is encoded +1 so that -1 is nonnegative.
	  const int f0 = GetNum() - 1;
	  const int f1 = GetNum() - 1;
	  const int f2 = GetNum() - 1;
	  const int f3 = GetNum() - 1;
	  const int f4 = GetNum() - 1;
	  const int f5 = GetNum() - 1;
	  fingerings.push_back(Pack(make_tuple(f0, f1, f2, f3, f4, f5)));
	}
      }
    }
    
    // sizeof DATA includes nul terminating byte.
    CHECK_EQ(idx + 1, sizeof DATA) << (idx + 1) << " " << (sizeof DATA);
  }

  // Outer vector is base chords, dense.
  // Then suffix, then each known fingering.
  vector<std::unordered_map<int, vector<PackedFingering>>> data;
};
}

static const DB *GetDB() {
  static const DB *db = new DB;
  return db;
}

std::vector<Guitar::Fingering> Guitar::GetFingerings(Chord c) {
  const DB &db = *GetDB();
  
  const int base = (c >> 8) & 255;
  CHECK(base >= 0 && base < Guitar::NUM_BASES) << "Invalid chord " << c;
  const auto &m = db.data[base];
  const int suf = c & 255;
  CHECK(suf >= 0 && suf < Guitar::NUM_SUFFIXES) << "Invalid chord " << suf;
  auto sit = m.find(suf);
  // No fingerings known.
  if (sit == m.end()) return {};
  // Convert to external representation.
  vector<Fingering> ret;
  ret.reserve(sit->second.size());
  for (const PackedFingering pf : sit->second)
    ret.push_back(Unpack(pf));
  return ret;
}
