// Generate a small standalone C++ class for a specific font, from its
// png file.

#include <cstdint>
#include <string>
#include <vector>
#include <memory>

#include "util.h"
#include "image.h"
#include "bit7chars.h"
#include "bitmap-font.h"
#include "base/stringprintf.h"
#include "base/logging.h"

using namespace std;
using uint8 = uint8_t;
using uint32 = uint32_t;
using uint64 = uint64_t;

constexpr int CHARS_ACROSS = 16;
constexpr int CHARS_DOWN = 8;
static_assert((CHARS_ACROSS * CHARS_DOWN) % 64 == 0,
	      "This code assumes a divisor of 64 bits, "
	      "which should be a consequence of having "
	      "128 characters!");

int main(int argc, char **argv) {
  CHECK(argc == 3) << "Usage: ./embedcc.exe w h\n";
  const int char_width = atoi(argv[1]);
  const int char_height = atoi(argv[2]);
  CHECK(char_width > 0) << "Width must be a number";
  CHECK(char_height > 0) << "Height must be a number";
  
  string filename = StringPrintf("test%dx%d.png", char_width, char_height);
  std::unique_ptr<ImageRGBA> input(ImageRGBA::Load(filename));
  CHECK(input.get() != nullptr) << "Couldn't load: " << filename;

  // Extract bits.
  vector<bool> bits;
  bits.resize(char_width * char_height * CHARS_ACROSS * CHARS_DOWN);
  for (int cy = 0; cy < CHARS_DOWN; cy++) {
    for (int cx = 0; cx < CHARS_ACROSS; cx++) {
      const int c = CHARS_ACROSS * cy + cx;
      for (int y = 0; y < char_height; y++) {
	for (int x = 0; x < char_width; x++) {
	  if (x < char_width && y < char_height) {
	    int sx = cx * char_width + x;
	    int sy = cy * char_height + y;
	    bool bit = (input->GetPixel(sx, sy) & 0x000000FF) > 0x0000007F;
	    bits[c * (char_width * char_height) + y * char_width + x] = bit;
	  }
	}
      }
    }
  }

  // Make into vector of words.
  CHECK((bits.size() % 64) == 0) << "Checked above";
  vector<uint64> words;
  int num_words = bits.size() / 64;
  words.reserve(num_words);

  for (int w = 0; w < num_words; w++) {
    uint64 word = 0;
    for (int bit = 0; bit < 64; bit++) {
      uint64 b = bits[w * 64 + bit] ? 0x1 : 0x0;
      word <<= 1;
      word |= b;
    }
    words.push_back(word);
  }
  CHECK((int)words.size() == num_words);
  
  // Now generate code.
  // Approach here is to generate a totally standalone thing, but
  // we could also think about e.g. allowing the bitmap-font library
  // to be initialized by whatever this generates.

  // Only needs <cstdint>.

  string out =
    StringPrintf(
	"// Generated by bit7/embedcc.cc.\n"
	"struct EmbeddedFont {\n"
	"  static constexpr int CHAR_WIDTH = %d;\n"
	"  static constexpr int CHAR_HEIGHT = %d;\n"
	"\n",
	char_width, char_height);

  out += R"(
  // No bounds checking!
  static constexpr bool GetBit(int c, int x, int y) {
    int b = c * (CHAR_WIDTH * CHAR_HEIGHT) + y * CHAR_WIDTH + x;
    return 0 != (words[b >> 6] & (1ULL << (63 - (b & 63))));
  }

  // SetPixel and ClearPixel called like SetPixel(x, y)
  // (if not null).
  template<class FS, class FC>
  static void Blit(int c, int x, int y, 
	           FS SetPixel, FC ClearPixel = [](int, int){}) {
    if (c < 0 || c >= 128) return;
    for (int sy = 0; sy < CHAR_HEIGHT; sy++) {
      for (int sx = 0; sx < CHAR_WIDTH; sx++) {
	if (GetBit(c, sx, sy)) {
	  SetPixel(x + sx, y + sy);
	} else {
	  ClearPixel(x + sx, y + sy);
	}
      }
    }
  })";
  
  StringAppendF(
      &out,
      "\n\n"
      " private:\n"
      "  static constexpr uint64_t words[%d] = {", // newline below
      num_words);
  
  for (int i = 0; i < (int)words.size(); i++) {
    if ((i % 3 == 0))
      out += "\n  ";
    else
      out += " ";
    StringAppendF(&out, "0x%016llxULL,", words[i]);
  }

  StringAppendF(&out,
		"\n"
		"  };\n"
		"};\n");


  printf("%s\n", out.c_str());

  return 0;
}
