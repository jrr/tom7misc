
This doc rules:
https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf

 -- timing -- 

NES:
Measured pin #38 (M2 -- this is CPU) on the saleae.
Example pulse: .36 us high .198 us low, which is 1.792 MHz.
           ie.  360 ns,    198 ns
On the pi, a for(;;) loop just calling gpio_write (one pin)
gets 80-88 ns pulse times

this is say .09 microseconds, which means we can do about
4 bit flips per NES clock. this is cutting it a bit close
but maybe in the "not insane" range?
  danger:
    - can I set multiple bits at that same rate?
       at a minimum I need to read the address bus, then
       write the data bus, then wait for the falling edge.
    - should make sure that transistors/diodes to do
      bridge between 3v3 and 5v ttl don't introduce too
      much slew etc. The analog waveform at 50MHz is 
      basically a sine wave so we may be reaching some
      electrical limits (?)
    - there are periodic dropouts. How to set realtime
      mode or whatever? We could probably cooperatively 
      schedule during ppu vblank
    - do we have enough time left to prepare CHR data?
    - do we have enough time left to do some emulation, etc.?

hmm, write_multi on 4 bits gives me 80ns/200ns off/on
cycle with a grosser waveform. 

But it looks like the ARM is just executing too many
instructions. With -O2, and removing debug test from
peri_write, I get 48ns/112ns off/on and a sinusoidal
wave. Plenty of more optimization to do...

 - inlined peri_write (this version also actually packs
   bits into the pins written, so that it's not trivial): 52ns/124
 - inlined all routines necessary to do write_mask: 44ns/120
 - memory barrier before/after: 48/80
 - barrier just before: 56/100

 -- more NES timing: PPU --

- The PPU RD bit happens as a solid square, .18 ON, .192 off.
  (but see "gap" below)
- This square wave happens for 15.305312ms.
- Then RD stays high for 1.334072ms.
  Together these add up to a period of 16.634, which is very
  close to 1/59.94, i.e. "60" FPS. So when RD is high we are
  probably in vblank. If we could manage to schedule other
  tasks here and fill the framebuffer on the pi, we'd be
  golden?
  (during the vblank, addresses are usually stable but
   sometimes there are glitches. trust RD.)
- Looks like addresses change when PPU RD is *high*, by
  the way, meaning that the address bits are safe to
  read when it's *low*. (This concurs with the docs,
  which call it /RD)
- Gap: I see a gap in reads (high cycle for .368 us) every 63.5us.
- 15305.312u (full frame) / 63.5us = 241 almost exactly,
  which I think means that this double-read is the end of
  a scanline.

 -- switching d0 --

This is not working right.

I have a 4.7k pullup from 5v to DATA.
- DATA is on the Collector of the NPN transistor. [ch 2]
- PIN 26 is on the Base of the transistor [ch 0], after a 10k resistor
- GND is on the Emitter.

We should be able to pull this close to ground (+ transistor drop) by closing
the transistor's circuit. But:

    ch 0              ch 2
 26 set = 3.3v       about 3.8v
 26 clear = 0.0v     about 4.9v

so it's like maybe I'm only turning on the voltage drop?
AHA! Perhaps the transistor is simply backwards [laughing crying emoji]
because the pinout on TO-92 IS NOT STANDARD!

fixed! now:

    ch 0              ch 2
 26 clear = 0.0v    about 4.9v
 26 set = 3.3v      about .03v


 -- how the NES works --

74LS139 (CPU side) is a simple multiplexer (2 bit address in, selecting
which of the four outputs gets LOW logic level; others are high). (Actually
it has two such circuits.) This is hooked up to CPU A13, A14, A15.
(I think it is selecting between sram, etc.?)
I think that on the schematic, the "E"nable pin is labeled C. Note how
one of the Y outputs from the left side is wired into the right half.
This means that neither Y1 (ppu reg) nor Y0 (cpu side SRAM)
will be enabled (pulled low) unless the right half is enabled by the
left half. The left half is always enabled (C to GND) and is selected
by address bits A15 and M2. Together the left half controls whether
the right half is enabled, plus outputs to pin 50 (on cartridge),
which is /ROMSEL. So the CPU can signal the A15 bit to the cartridge
with every address, clocked with M2. Not sure what this is used for
exactly (it already gets A0-A14 directly, not to mention M2).

 -- cpu/ppu communication --

To write to PPU VRAM, you use memory mapped cpu registers;
two bytes to $2006 to set the address, then bytes written to
$2007 get streamed into incrementing addresses. (It's also possible
to increment by 32, which moves "down" since the screen is 32 tiles
wide.)

On the board, cpu has 3 address bits wired to the CPU to select the
PPU register (there are 8 of them), and an 8-bit bidirectional bus.
/CS is pulled low by that 74LS139 address multiplexer (not sure
in what conditions exactly) so that $2007 selects register 0b111.
Apparently the condition is that the address is from $2000 to $3fff;
the middle bits are just dropped. 

specifically, the address is:
001* **** **** *ppp
where * is ignored, ppp selects the ppu register, and 001 is setting
the range $2000-$3fff. The 1 here is A13. If you look at how the 74139
is wired, this makes sense, since the right half has A13 and A14 as
inputs (and is only enabled when A15 is low), and PPU /DBE as one of
its outputs.

 -- ppu memory mapping --

On the PPU side, this works differently:
The 2k SRAM chip (officially CIRAM, aka VRAM) is
enabled directly from the cart. Pin 57, aka CIRAM /CE, enables the
chip when low. The PPU RD and PPU WR lines are wired directly to CIRAM,
also connected to the cart traces.
A10, the highest bit of the chip's address space, is controlled by
the cart--not hooked directly into PPU. (I guess probably some carts just
wire this directly from PPU A10 though?)

Anyway, ppuppy should disable CIRAM (wire /CE high) so that it can
just supply its own data.

 -- ppu rendering --
Nice simple explanation from nesdev wiki (PPU nametables article):


Conceptually, the PPU does this 33 times for each scanline:

A. Fetch a nametable entry from $2000-$2FBF.
B. Fetch the corresponding attribute table entry from $23C0-$2FFF and
   increment the current VRAM address within the same row.
C. Fetch the low-order byte of an 8x1 pixel sliver of pattern table from $0000-$0FF7 or $1000-$1FF7.
D. Fetch the high-order byte of this sliver from an address 8 bytes higher.
E. Turn the attribute data and the pattern table data into palette
   indices, and combine them with data from sprite data using priority.

It also does a fetch of a 34th (nametable, attribute, pattern) tuple
that is never used, but some mappers rely on this fetch for timing
purposes.

Note nametable would usually be RAM. We could disable this and supply our own
values, though. (This is probably why we see data on the data bus D0
all throughout the scanline, even when we aren't outputting anything.
This is not a vram write, it's SRAM asserting a value on that same bus.)


