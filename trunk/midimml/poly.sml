
(* This is the "Polyphonic" version of MIDIMML.
   
   If it sees overlapping notes in the input MIDI, then it can
   generate a rapid arpeggio between them, to simulate polyphony. This
   generally sounds bad. *)

structure Poly =
struct

  val config =
    Params.param "default.mmc"
       (SOME ("-config",
              "Set the config file. Look at default.mmc for an example."))
       "config"

  val outpath =
    Params.param ""
       (SOME ("-out",
              "Set the directory in which to write the mml output."))
       "outpath"

  fun getbase f =
    (case StringUtil.rfind "\\" f of
       NONE => f
     | SOME n => String.substring(f, n + 1, size f - (n + 1)))

  exception MML of string

  val itos = Int.toString

  (* get the name of a track *)
  fun findname nil = NONE
    | findname ((_, MIDI.META (MIDI.NAME s)) :: _) = SOME s
    | findname (_ :: rest) = findname rest


  (* make note-on 0 be note-off *)
  fun clean (MIDI.NOTEON (a, b, 0)) = MIDI.NOTEOFF (a, b, 0)
    | clean x = x

  fun doconfig wrl f =
    let 

      val title = ref ""
      val composer = ref ""
      val programmer = ref ""
      val drumpath = ref ""
      val drums = ref nil
      val quote = ref nil

      fun oneline s =
        case StringUtil.token StringUtil.whitespec s of
          ("TITLE", t) => title := t
        | ("COMPOSER", c) => 
            let in
              composer := c;
              if !programmer = ""
              then programmer := c
              else ()
            end
        | ("PROGRAMMER", p) => programmer := p
        | ("PROGRAMER", p) => programmer := p
        | ("DRUMPATH", dp) => drumpath := dp
        | ("DRUM", d) =>
            (case String.tokens StringUtil.whitespec d of
               [sample, midinote] =>
                 (case Int.fromString midinote of
                    SOME i => drums := (i, OS.Path.concat(!drumpath, sample))
                                        :: !drums
                  | NONE => 
                      raise MML "config: midi note must be a number")
             | _ => raise MML
                    ("config: DRUM must be followed by a " ^
                     "sample name and midi note number"))
        | ("QUOTE", q) => quote := q :: !quote
        | ("", "") => ()
        | ("#", _) => ()
        | (what, _) => raise MML ("config: unrecognized command '" ^
                                  what ^ "'")


      val fd = TextIO.openIn f

      fun rconf () =
        case TextIO.inputLine fd of
          NONE => TextIO.closeIn fd
        | SOME line =>
            (* lose trailing whitespace *)
            (oneline (StringUtil.losespecr StringUtil.whitespec line);
             rconf ())

      val _ = rconf ()

      val drums = ListUtil.mapi (fn ((s, path), i) => (s, (i, path))) (!drums)

      (* returned from config generator *)
      fun mapdrums x =
        case ListUtil.Alist.find op= drums x of
          NONE => raise MML ("drum for MIDI note #" ^ itos x ^ 
                             " never defined in config")
        | SOME (idx, _) => idx

      fun emitdrum (s, (i, path)) =
        wrl ("@DPCM" ^ StringUtil.padex #"0" 2 (Int.toString i) ^ 
             " = { \"" ^ path ^ "\" 15 }")

    in
      wrl ("#TITLE " ^ !title);
      wrl ("#COMPOSER " ^ !composer);
      wrl ("#PROGRAMER " ^ !programmer);
      wrl "";
      wrl "/* generated by midimml */";
      wrl "";

      app wrl (rev (!quote));

      (* calibrate drum track to octave 0 *)
      wrl "E o0";
      wrl "";

      app emitdrum drums;
      
      mapdrums
    end

  fun write (_, _, tracks) name =
    let
      val notes = Vector.fromList
        ["c", "c+", "d", "d+", "e", "f", "f+", "g", "g+", "a", "a+", "b"]

      fun warn msg = print (getbase name ^ ": Warning: " ^ msg ^ "\n")

      (* current octave *)
      val co = ref 999

      fun mknote (n, false) =
        let val t = n - 24
          val octave = 1 + t div 12
        in 
          if t >= 0
          then
            (if !co <> octave then (co := octave; 
                                    "o" ^ itos (1 + t div 12) ^ " ")
             else "") ^ Vector.sub(notes, t mod 12)
          else raise MML "note too low"
        end
      (* direct, like for drums *)
        | mknote (n, _) =
        Vector.sub(notes, n)

      val f = TextIO.openOut name
      fun wr s = TextIO.output (f, s)
      fun wrl s = (TextIO.output (f, s);
                   TextIO.output (f, "\n"))

      (* XXX calculate this table based on tempo *)
                 (* midi frames, nth note *)
      val times = [(512, 1),
                   (256, 2),
                   (128, 4),
                   (64, 8),
                   (32, 16),
                   (16, 32),
                   (8, 64),
                   (4, 128),
                   (2, 256),
                   (1, 512)]

      (* current octave *)
      val co = ref 999
      (* current velocity *)
      val cv = ref 999
      (* current length *)
      val cl = ref 0

      fun mktime n =
        let 
          fun findy _ nil = raise MML "can't make 0 time" 
            | findy m ((fr,th)::rest) =
            if m = fr
            then itos th
            else if m > fr
                 then itos th ^ "^" ^ findy (m - fr) ((fr,th)::rest)
                 else findy m rest
          val tt = findy n times
        in
          findy n times
        end

      fun wrvel vel =
        let val veloc = vel div 8
        in
          if !cv <> veloc
          then (wr ("v"  ^ itos veloc ^ " ");
                cv := veloc)
          else ()
        end

      fun onenote nmap (n,v) =
        let in
          (* single note *)
          wrvel v;
          wr (mknote (nmap n))
        end
      
      fun makesound nmap notes 0 =
        (case notes of
           nil => ()
         | _ => warn "0-length notes??")
        | makesound nmap notes ticks =
        (case notes of
           nil =>
             let in
               (* rest ... *)
               wr ("r" ^ mktime ticks ^ " ")
             end
         | [one] =>
             let in
               onenote nmap one;
               wr (mktime ticks);
               wr " "
             end
         | many =>
             let 
               val num = length many
               val reps = ticks div num
               val left = ticks mod num
             in
               (* what about 1? *)
               if reps > 0
               then
                 let in
                   wr ("[l" ^ mktime 1 ^ " ");
                   app (onenote nmap) many;
                   wr "]";
                   wr (itos reps);
                   wr " "
                 end
               else ();
               (* write leftovers *)
               if left > 0 then
                  let in
                    wr ("l" ^ mktime 1 ^ " ");
                    app (onenote nmap) (List.take (many, left));
                    wr " "
                  end
               else ()
             end)

      (* called with track name ("A") and list of
         (name option, MIDI track)s that match it. *)
      fun dowrite nmap s ts =
        let
          val _ = cv := 999
          val _ = cl := 999
          val _ = co := 999

            
          fun warn msg = print (getbase name ^ "(" ^ s ^ 
                                "): Warning: " ^ msg ^ "\n")

          (* get all the events at the next tick. *)
          (* n = smallest delta on any track. 
             subtract n from the delta for each
             track, then report all events with
             delta 0, and return n. *)
          fun nextevents trl =
            let
              val ttl = ListUtil.sort 
                (fn (nil, nil) => EQUAL
                  | (_, nil) => LESS
                  | (nil, _) => GREATER
                  | ((d,_)::_, (c,_)::_) => Int.compare (d, c)) trl
            in
              case ttl of
                ((n, _)::_)::_ =>
                  let
                    (* subtract *)
                    val ntl = map (fn nil => nil
                                    | (d, e)::t => (d-n,e)::t) ttl

                    (* get all 0-time events from the head of list,
                       return rest too *)
                    fun gete l =
                      let val (zero, rest) =
                        ListUtil.partitionaslongas
                        (fn (0, _) => true | _ => false) l
                      in
                        (map #2 zero, rest)
                      end

                    (* get any events with delta 0 *)                    
                    val (zeros, rests) = ListPair.unzip (map gete ntl)

                  in
                    (n, List.concat zeros, rests)
                  end
               | _ =>
                  let in
                    print "No more events in any track.\n";
                    print "Perhaps missing \"end\" marker?\n";
                    raise MML "bad midi"
                  end
            end

          (* process a state (list of on notes)
             by getting the next chunk of events,
             and then dumping sound for the interval. *)
          fun process (state as (notes, time)) ts =
            let
              val (n, now, ts) = nextevents ts

              (* turn noteon 0 -> noteoff *)
              val now = map clean now

              (* change the notes list. ignore channels. *)
              fun proce (MIDI.NOTEON (_, nn, vel), notes) =
                (case List.partition (fn (num, vel) =>
                                      num = nn) notes of
                   (nil, notes) => (nn, vel) :: notes
                 | (_, notes) =>
                     let in
                       warn "note-on for note already on!";
                       notes
                     end)
                | proce (MIDI.NOTEOFF (_, nn, _), notes) =
                (case List.partition (fn (num, vel) =>
                                      num = nn) notes of
                   (nil, notes) =>
                     let in
                       warn "note-off for note that was off!";
                       notes
                     end
                 | (_, notes) => notes)
                | proce (_, notes) = notes

              (* get new notes *)
              val newnotes = foldl proce notes now

              fun hasmark s nil = false
                | hasmark s (MIDI.META (MIDI.MARK m) :: rest) =
                s = m orelse hasmark s rest
                | hasmark s (_ :: t) = hasmark s t

              fun getmark s nil = NONE
                | getmark s (MIDI.META (MIDI.MARK m) :: rest) =
                if StringUtil.matchhead s m
                then SOME m
                else getmark s rest
                | getmark s (_ :: t) = getmark s t

            in
              (* generate sound for n + time steps (previous
                 frames) *)
              makesound nmap notes (n + time);

              (* start loop if "loop" marker *)
              if hasmark "loop" now
              then wr "L "
              else ();

              case getmark "t" now of
                NONE => ()
              | SOME t => wr (t ^ " ");

              (* if no "end" marker, continue ... *)
              if hasmark "end" now
              then ()
              else process (newnotes, 0) ts
            end

        in
          wr "\n\n";
          wr (s ^ " ");
          process (nil, 0) ts
        end

      (* get tracks starting with s,
         or with no name (control track) *)
      fun tracksfor s nil = nil
        | tracksfor s (h::t) =
        case findname h of
          NONE => h :: tracksfor s t
        | SOME tn => if StringUtil.matchhead s tn
                        orelse tn = "untitled" (* sonar XL *)
                     then h :: tracksfor s t
                     else tracksfor s t

      fun id x = (x, false)
      fun add n x = (n + x, false)

      val mapdrums = doconfig wrl (!config)

      val mapdrums = fn x => (mapdrums x, true)

    in

      app (fn (s,mapper) =>
           dowrite mapper s (tracksfor s tracks)) 
          [("A",id), ("B",id), ("C",add 12), ("D",id), ("E", mapdrums)];

      wrl "";
      wrl "/* end */";
      wrl "";
      TextIO.closeOut f
    end


  fun convert f =
    let 
      val r = Reader.fromfile f
      val m = MIDI.readmidi r

      val base = getbase f

      val out = 
        !outpath ^ 
        (case StringUtil.find "." base of
           NONE => base
         | SOME n => String.substring(base, 0, n)) ^ ".mml"
    in 
      #close r ();
      write m out
    end handle (e as (MML s)) => (print ("Error: " ^ s ^ "\n"); raise e)
       | (e as (MIDI.MIDI s)) => (print ("Bad MIDI: " ^ s ^ "\n"); raise e)

end

