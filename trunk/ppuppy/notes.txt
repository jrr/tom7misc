
This doc rules:
https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf

 -- timing -- 

NES:
Measured pin #38 (M2 -- this is CPU) on the saleae.
Example pulse: .36 us high .198 us low, which is 1.792 MHz.
           ie.  360 ns,    198 ns
On the pi, a for(;;) loop just calling gpio_write (one pin)
gets 80-88 ns pulse times

this is say .09 microseconds, which means we can do about
4 bit flips per NES clock. this is cutting it a bit close
but maybe in the "not insane" range?
  danger:
    - can I set multiple bits at that same rate?
       at a minimum I need to read the address bus, then
       write the data bus, then wait for the falling edge.
    - should make sure that transistors/diodes to do
      bridge between 3v3 and 5v ttl don't introduce too
      much slew etc. The analog waveform at 50MHz is 
      basically a sine wave so we may be reaching some
      electrical limits (?)
    - there are periodic dropouts. How to set realtime
      mode or whatever? We could probably cooperatively 
      schedule during ppu vblank
    - do we have enough time left to prepare CHR data?
    - do we have enough time left to do some emulation, etc.?

hmm, write_multi on 4 bits gives me 80ns/200ns off/on
cycle with a grosser waveform. 

But it looks like the ARM is just executing too many
instructions. With -O2, and removing debug test from
peri_write, I get 48ns/112ns off/on and a sinusoidal
wave. Plenty of more optimization to do...

 - inlined peri_write (this version also actually packs
   bits into the pins written, so that it's not trivial): 52ns/124
 - inlined all routines necessary to do write_mask: 44ns/120
 - memory barrier before/after: 48/80
 - barrier just before: 56/100

 -- more NES timing: PPU --

- The PPU RD bit happens as a solid square, .18 ON, .192 off.
  (but see "gap" below)
- This square wave happens for 15.305312ms.
- Then RD stays high for 1.334072ms.
  Together these add up to a period of 16.634, which is very
  close to 1/59.94, i.e. "60" FPS. So when RD is high we are
  probably in vblank. If we could manage to schedule other
  tasks here and fill the framebuffer on the pi, we'd be
  golden?
  (during the vblank, addresses are usually stable but
   sometimes there are glitches. trust RD.)
- Looks like addresses change when PPU RD is *high*, by
  the way, meaning that the address bits are safe to
  read when it's *low*. (This concurs with the docs,
  which call it /RD)
- Gap: I see a gap in reads (high cycle for .368 us) every 63.5us.
- 15305.312u (full frame) / 63.5us = 241 almost exactly,
  which I think means that this double-read is the end of
  a scanline.
