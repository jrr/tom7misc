\documentclass[twocolumn]{amsart}
\usepackage[top=0.5in, left=0.45in, right=0.45in, bottom=0.5in]{geometry}

\usepackage{url}
% \usepackage{code}
% \usepackage{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{chessboard}

% \usepackage{chessfs}
\usepackage{adjustbox}

% Define black versions of pieces for inline use. Gross, but it works.
\newcommand{\Pawn}[1][1.3ex]{%
\adjustbox{Trim=4.3pt 2.6pt 4.3pt 0pt,width=#1,margin=0.2ex 0ex 0.2ex 0ex}{\BlackPawnOnWhite}%
}%
\newcommand{\Rook}[1][1.58ex]{%
\adjustbox{Trim=3.2pt 2.2pt 3.2pt 0pt,width=#1,raise=0ex,margin=0.1ex 0ex 0.1ex 0ex}{\BlackRookOnWhite}%
}%
\newcommand{\Knight}[1][1.85ex]{%
\adjustbox{Trim=2.3pt 2.35pt 2.5pt 0pt,width=#1,raise=-0.03ex,margin=0.14ex 0ex 0.14ex 0ex}{\BlackKnightOnWhite}%
}%
\newcommand{\Bishop}[1][1.79ex]{%
\adjustbox{Trim=2.3pt 2pt 2.3pt 0pt,width=#1,raise=-0.12ex,margin=0.1ex 0ex 0.1ex 0ex}{\BlackBishopOnWhite}%
}%
\newcommand{\Queen}[1][2.05ex]{%
\adjustbox{Trim=1.2pt 2.2pt 1.2pt 0pt,width=#1,raise=-0.08ex,margin=0.1ex 0ex 0.1ex 0ex}{\BlackQueenOnWhite}%
}%
\newcommand{\King}[1][1.95ex]{%
\adjustbox{Trim=2pt 2pt 2pt 0pt,width=#1,raise=-0.06ex,margin=0.13ex 0ex 0.13ex 0ex}{\BlackKingOnWhite}%
}%

\interfootnotelinepenalty=0

% lets me explicitly set a. or 1. etc. as enum label
\usepackage{enumitem}

\pagestyle{empty}

\usepackage{ulem}
% go back to italics for emphasis, though
\normalem

\usepackage{natbib}

\setlength{\footnotesep}{2em}

% \newcommand\comment[1]{}
\newcommand\sfrac[2]{\!{}\,^{#1}\!/{}\!_{#2}}

\begin{document} 

\title{Color- and piece-blind chess}
\author{Dr.~Tom~Murphy~VII~Ph.D.}\thanks{
Copyright \copyright\ 2019 the Regents of the Wikiplia Foundation.
Appears in The Journal Of LaTeX Class Files with the insufficient
material of the Association for Computational Heresy; {\em IEEEEEE!}
press, Verlag-Verlag volume no.~0x40-2A. 1 tempo}

\setchessboard{showmover=false}

\newcommand\checkmate{\hspace{-.05em}\raisebox{.4ex}{\tiny\bf ++}}

\renewcommand\th{\ensuremath{{}^{\textrm{th}}}}
\newcommand\st{\ensuremath{{}^{\textrm{st}}}}
\newcommand\rd{\ensuremath{{}^{\textrm{rd}}}}
\newcommand\nd{\ensuremath{{}^{\textrm{nd}}}}
\newcommand\at{\ensuremath{\scriptstyle @}}

\date{1 April 2019}

\maketitle \thispagestyle{empty}

% \begin{abstract}
% CHESSMATE.
% \end{abstract}

\section{Impressing humans}

What better way for humans to impress each other with their brains,
especially in movies, than to play chess---and to shout dramatically
CHECKMATE! upon surprise-checkmating their opponent? Well, one way is
to play chess while disadvantaged somehow, for example, by punching
each other in the face repeatedly during the game to impair brain
function (see Chess Boxing~\cite{chessboxing}). Another common
distraction is to play a multitude of games against many opponents at
the same time, in a so-called ``simultaneous exhibition.'' The idea is
that this is more challenging because of the need to maintain mental
state for so many games at once, whereas your opponents only need to
maintain state for one game. In truth, simultaneous exhibitions easily
fall to a ``man-in-the-middle attack.'' If the purported genius simply
creates a bipartite matching of the games played with the white pieces
and the games played with black, he can mechanically forward moves
between these pairs of boards. This requires only constant state (see
next section) per pair of games, and guarantees an even score for the
exhibition. So that's not very impressive.

Another disadvantage that humans sometimes use to impress each other
is a blindfold (worn over the eyes). In this predicament they only
hear the opponent announce moves and must keep the position on the
board in their mind's eye, both for the sake of remembering it and
while exploring potential moves.
% This is effective, since although the .
Disadvantages can be combined, such as in the final scene of the 1988
documentary {\it Bloodsport} where Jean Claude van Damme is blinded by
an illicit foreign substance during the final martial art
battle.\footnote{JCVD does not play chess on camera, but it is implied
  that he is also holding a simultaneous exhibition between rounds in
  a different room of the underground Hong Kong illegal karate
  complex.}

\section{Impressing computers}

In contrast, it is much more difficult to impress computers or impress
people with computers. When it comes to computers playing chess,
largely, the jig is up; it is now easy for chess programs, running on
consumer hardware, to defeat the strongest human players. It is well
known that striking a computer actually {\em fixes} it, so chess
boxing becomes trivial. Blindfold chess is the natural interface for a
chess computer; it is actually {\em much more difficult} to have the
computer interpret the opponent's move by visually studying a physical
board!

Playing multiple games simutaneously is an easy extension of playing a
single game, although in principle the scale of such a thing could
still be impressive. With a modern chess engine, it is easy to scale
to an arbitrary number of games, since the exhibitor can make progress
by observing one of the boards, computing a strong move, and playing
it; this requires $O(0)$ space because all of the state is stored
externally in the exhibition itself. 
% If playing blindfold, then the
% main cost is storing the state of each game. 
However, we run the risk of losing the tournament (other players may
be yet stronger computers). The man-in-the-middle attack remains an
efficient way way to minimize loss (ensuring an exactly even score).
The simplest way to do this is to explicily generate a perfect
bipartite matching over the $n$ games $G$ being played. This consists
of $n/2$ pairs $\langle G_w, G_b \rangle$ (where we play as white
against Bob and black against Walice, respectively). Since each game
starts in the starting position, this is very easy; we can just assign
the matches consecutively. Along with each pair we also record which
of the following states we are in:
\begin{enumerate}
\item We are waiting for a move from Walice (our white opponent) \label{state:mim1}
\item We have seen a move from Walice, which is \underline{\hspace{6em}}. \label{state:mim2}
\item We are waiting for a move from Bob (our black opponent) \label{state:mim3}
\item We have seen a move from Bob, which is \underline{\hspace{6em}}. \label{state:mim4}
\end{enumerate}
If in State~\ref{state:mim1}, we just watch $G_b$ until Walice makes a
move, then record it and proceed to State~\ref{state:mim2}. We consume
the move and move to State~\ref{state:mim3} by playing that move in
$G_w$ against Bob (where it must be our turn). We can immediately seek
out that game or wait until we naturally come upon it. However, we
should only approach $G_w$ when the pair of games is in
State~\ref{state:mim3}, etc., otherwise we will not have a move to play.

There are $n/2$ pairs, with two bits for the state, no more\footnote{
  There are only 1792 pairs of squares between which pieces can ever
  move (Section~\ref{sec:legalmove}), so $11+2$ bits suffices, with
  some added complexity.} than $\log_2(64 * 64 * 4) = 14$ bits for
each move (source square, destination square, and 2 bits to
distinguish promotion to queen, rook, bishop, or knight). However, we
also need to store the matching of $G_w$ to $G_b$; this can be done
with a pair of indices (or e.g. memory addresses) but unfortunately,
this requires $\log_2(n)$ bits to represent. So overall this approach
requires $O(n \log(n))$ space to play a simultaneous exhibition of $n$
games.

It appears to be possible to reduce the space usage per game to a
constant. In order to perform a man-in-the-middle attack, we need
a perfect matching between the white games and black games. It is
not essential that the matching be stable over time; for example
if we are forwarding moves between Walice and Bob, and between
Waluigi and Bario, and these games happen to transpose to the same
position, then it works just fine to switch to forwarding between
Walice and Bario; Waluigi and Bob. So, rather than store the
matching explicitly, we can reconstruct it from the stored state.
We two vectors of $n/2$ rows, the ``source'' and ``destination'' rows,  (XXX I think we do not need destination)
each containing a game {\em position} (not move).
This position represents XXXX (like the last time we saw it?).
The positions are initialized to the starting position. Like before
we can be in one of four states:
\begin{itemize}
\item Waiting for all ``source'' players (who play as white) to complete their moves. \label{state:cmim1}
\item Forwarding our moves from ``source'' to our black opponents. \label{state:cmim2}
\item `` \ldots '' (who play as black) `` \ldots '' \label{state:cmim3}
\item `` \ldots '' white opponents. \label{state:cmim3}
\end{itemize}

\newcommand\stepsto[1]{\stackrel{#1}{\rightarrow}}

% (XXX So actually, simpler here is just: Loop until all white players have
% made their moves. Then copy all their boards to our board vector.)
While in State~\label{state:cmim1} (which we also start in), we
compare our stored source board states to the boards where we play as
black. Once the white opponent has made a move, resulting in $B'$,
there will be some position $B$ in our ``source'' set that is a valid
predecessor for $B'$ (that is, there exists some legal move $M$ that
advances $B$ to $B'$). For example, at the beginning, $B$ may be the
starting position (in fact it must, since all boards are initialized
this way) and $B'$ may be the position resulting from $1. e4$. With
the matching constructed (see below) we copy each $B'$ into our set of
boards, forgetting $B$.\footnote{In fact, we do not even need to
  construct the matching, although it may help us with bookkeeping
  (e.g., which games have already been copied?), depending on how the
  exhibition itself is represented.} Then we transition to
State~\label{state:cmim2}. In this state, we figure out what moves to
play in the pending boards. By invariant, each one $B$ will be
compatible with at least one of our source boards $B'$. Compatible
means that there exists a move $m$ where playing $m$ in board $B$
results in $B'$. If $m$ exists, it is unique (and easy to compute), so
this is the move that we will play. The only tricky thing is figuring
out which boards go with which; this is the problem of reconstructing
the perfect matching.

Although if $B \stepsto{m} B'$ it is easy to deduce $m$, it is not
possible to compute $B$ from $B'$, or even from $B'$ and $m$. This is
because we may have both $B_a \stepsto{m_a} B'$ and $B_b \stepsto{m_b}
B'$ with $B_a \neq B_b$. For example with $B'$

\chessboard[tinyboard, setfen=k7/8/8/8/8/8/8/K7 w - -, showmover]

we could have $B_a$ and $B_b$ be

\chessboard[tinyboard, setfen=Nk6/8/8/8/8/8/8/K7 b - -, showmover]
\chessboard[tinyboard, setfen=Rk6/8/8/8/8/8/8/K7 b - -, showmover]

Both of which can precede $B'$ (the move is even the same: Kxa1).
So it is not enough to greedily assign edges in our perfect match;
if we choose the edge $B_b$ to go with $B'$, we might later find
$B'_2$:

\chessboard[tinyboard, setfen=R7/1k6/8/8/8/8/8/K7 w - -, showmover]

\ldots and have no possible matching board, since it cannot follow
$B_a$.

Fortunately, we know the
 - there exists a perfect matching (players playing legally)
 - we can tell if we found one

so you have a set of black and white games, same number of each.
goal is to get an even score, while using O(n) space.
So we have an invariant that each of the games-as-white is paired
with at least one compatible game-as-black (and vice versa). Of
course at the beginning all pairs are compatible, and then white
makes a move; the games are still compatible because any of these
moves can be played on the black side. We just need to make sure
that we don't play e.g. e4 in all the games, because we need enough
black opponents to be playing against d4s and Nf3s and so on.
So, after all the white players have made their moves, we have
those boards, and need to make moves for black. For each, just pick
a compatible board (i.e., something that represents a legal move)
and play it. When we do so, we update the board to a state like
``I made this move as white.'' (So at the very beginning, all boards
are in the starting position with like ``I made this move as black,''
of course not really, more like ``white opponent to move'').
This is easy on the first move because all choices (that are in
the state ``copied this move from white'').

Now we wait for black players to make their moves. (Note waiting
can be done in constant space. You just compare each board that
has ``black opponent to move'' with the actual board state; if
the move is compatible then you update it. But might you confuse
the identities of two games? It would need to be the case that
there exists board states $B_1$, $B_2$, $B$ where $B$ can
legally follow $B_1$ and $B_2$ but $B_1$ and $B_2$ are different.
Of course this is possible! $B$ could be like 

\chessboard[tinyboard, setfen=k7/8/8/8/8/8/8/K7 w - -, showmover]

and then we have $B_1$ and $B_2$ as

\chessboard[tinyboard, setfen=1k6/8/8/8/8/8/8/K7 b - -, showmover]
\chessboard[tinyboard, setfen=Rk6/8/8/8/8/8/8/K7 b - -, showmover]

And so if we misassign $B$ to $B_1$, and then later see $B'$:

\chessboard[tinyboard, setfen=R7/1k6/8/8/8/8/8/K7 w - -, showmover]

We are stuck because $B'$ cannot follow $B_2$.

So if we're actually going to do it with this method, we would
need to be able to compute the bipartite matching looking at all
the constraints. There certainly exists one, and any one will do. 
(Actually what we want is called a ``perfect matching.'')
So the question is, can we compute a perfect matching in constant
space? I mean, it seems like not. How could we even {\em store}
the matching? Well, we don't actually need to store the matching
because it's not *literally* what we need; we just want to have
assigned the games according to a perfect match. So one approach
is like, pick a random assignment. If we get stuck, just start
over (so we would have to keep two board states, in order to
be able to ``undo'', but that is still constant) and commit
the whole thing if we succeed. We're actually quite likely to
succeed since ambiguities are pretty rare. So this may work
fine in practice. The main thing we achieve here is that we
don't need to store the matching itself between rounds; the
matching is ``expensive'' because it contains an index, which
is logarithmic size in the number of games. So, with this
method, we get $O(n)$ space, which is actually around $200 n$.


For each pair, we store the state of the board $B$
as last we saw it in $G_w$ or $G_b$.

both Walice and Bob have made their moves (that is, it is white's turn
in $G_w$ and 

$G_i$, we look up which pair $p$ it is, and look at $B_p$. This board


Note that 

Computers can still impress us and each other with computational chess
feats other than playing. For example, computers are largely concerned
with filling up their memories with efficiently encoded data.

compactly storing a position. constant state

I think a version I liked was 64 bits (this gives the positions of all
pieces),\footnote{(We can also do a little better. Note that only up
  to 32 of the 64 bits can be set, so you could represent
  $\binom{60}{32}$ in $\sim 61$ bits and use e.g. a third king to
  indicate that there are no more actually occupied squares if fewer
  than 32 pieces are present. However, this gets vastly more
  complicated for only 3 bits of savings.)} followed by 32 records
giving the piece values (there are 6: pawn, knight, bishop, rook,
queen, king) and colors. To pick between the 12 possibilities we need
4 bits, and there is some slack here of course. anyway, that's 64 +
32*4 = 192 bits, plus 15 bits for other state. Note we could use the
c\_rook trick to save 4 bits for castling rights (14 possibilities),
not to mention a en\_passantable pawn (15) and a king whose turn it is
(even 16). Clear slack here, but that would leave only the 50-move
rule at 7 bits, for a total of 199. Wikipedia says the huffman
approach is ``maximum of 204 bits, and often much less.'' but the
article also contains many bugs, like the misconception that there can
only be four rooks.

So now comes the main idea of the paper, which is also spoilered in the
very clear paper title. What if we represented boards {\em only} as the
64-bit mask telling us what squares are occupied? The encoding is very
lossy, of course, but it often contains enough information to deduce
the state of the board, or ...

% 
% % make -j eval-unblinder.exe && ./eval-unblinder.exe net.val
% .!Evaluating model net.val...
% Loaded 50000 positions in 122.59s
% Loaded model in 0.10s
% Ran eval in 2.04s
% Reading [net.val]
% net.val: 4 layers.
% net.val: num nodes: 64 1024 12288 567 837
% net.val: indices per node/fns: 49 LEAKY_RELU 36 LEAKY_RELU 127 LEAKY_RELU 78 LEAKY_RELU
% Read from net.val.
% Invert index:
% Check it:
% ModelInfo [339885 rounds, 223224128 examples]
% Over 50000 positions:
%   9584 exactly correct (19.17%)
%   161166 piece mistakes (3.22/pos)
%   1630 castling mistakes (0.03/pos)
%   19014 move mistakes (0.38/pos)
%   181810 total mistakes (3.64/pos)
% 
% % $ make -j eval-unblinder.exe && ./eval-unblinder.exe net-before-vacuum.val
% make: 'eval-unblinder.exe' is up to date.
% Evaluating model net-before-vacuum.val...
% Loaded 50000 positions in 118.80s
% Loaded model in 3.99s
% Ran eval in 332.10s
% Reading [net-before-vacuum.val]
% net-before-vacuum.val: 4 layers.
% net-before-vacuum.val: num nodes: 64 1024 12288 567 837
% net-before-vacuum.val: indices per node/fns: 64 LEAKY_RELU 1024 LEAKY_RELU 12288 LEAKY_RELU 567 LEAKY_RELU
% Read from net-before-vacuum.val.
% Invert index:
% Check it:
% ModelInfo [146999 rounds, 9407936 examples]
% Over 50000 positions:
%   10601 exactly correct (21.20%)
%   156052 piece mistakes (3.12/pos)
%   1542 castling mistakes (0.03/pos)
%   18818 move mistakes (0.38/pos)
%   176412 total mistakes (3.53/pos)
% 
% 
% 
% without concurrent processes:
% net.val: 1.61s  (something like 1035/sec/core)
% net-before-vacuum: 229.85s (something like 7/sec/core)
% 
% 
% single_kings net.val:
% Over 50000 positions:
%   9642 exactly correct (19.28%)
%   162804 piece mistakes (3.26/pos)
%   1633 castling mistakes (0.03/pos)
%   19014 move mistakes (0.38/pos)
%   183451 total mistakes (3.67/pos)
% 
% It's actually kind of heartening that it performs worse with this approach,
% though we are more likely to get the whole board correct.
% 
% (cite #kingme)
% 

% all bits set to 1 (with single_kings)
% (without single_kings, only difference is that the bottom right becomes a
% rook; no white queen)
\includegraphics[width=0.9 \linewidth]{blind-allon}

\bibliography{chess}{}
\bibliographystyle{plain}

\end{document}
