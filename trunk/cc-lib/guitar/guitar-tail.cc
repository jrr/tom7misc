
// Note: In guitar.cc, this file is assembled from guitar-head.cc,
// guitar-tail.cc, and some data generated by gencc.cc. Don't edit
// guitar.cc directly.

#undef DEBUG_GUITAR

// Normalize the guitar chord name if possible.
// Sharps/flats on the base chord are rewritten to one of
// C#, Eb, F#, Ab, Bb.
static string NormalizeBase(string s) {
  if (Util::StartsWith(s, "Db")) {
    s[0] = 'C';
    s[1] = '#';
  } else if (Util::StartsWith(s, "D#")) {
    s[0] = 'E';
    s[1] = 'b';
  } else if (Util::StartsWith(s, "Gb")) {
    s[0] = 'F';
    s[1] = '#';
  } else if (Util::StartsWith(s, "G#")) {
    s[0] = 'A';
    s[1] = 'b';
  } else if (Util::StartsWith(s, "A#")) {
    s[0] = 'B';
    s[1] = 'b';
  }
  return s;
}

static inline Guitar::Chord ChordOfUnchecked(int base_num,
					     int suffix_num) {
  return (base_num << 8) | suffix_num;
}

static inline pair<int, int> UnChord(Guitar::Chord c) {
  const int base = (c >> 8) & 255;
  const int suf = c & 255;
  return make_pair(base, suf);
}

Guitar::Chord Guitar::ChordOf(int b, int s) {
  CHECK(b >= 0 && b < NUM_BASES) << b;
  CHECK(s >= 0 && s < NUM_SUFFIXES) << s;
  return ChordOfUnchecked(b, s);
}

static string NormalizeSuffix(const string &s) {
  if (s == "major" || s == "maj") return "";
  if (s == "minor" || s == "min") return "m";
  return s;
}

int Guitar::BaseNum(string_view base) {
  for (int i = 0; i < NUM_BASES; i++) {
    if (BASES[i] == base) return i;
  }
  return -1;
}

int Guitar::SuffixNum(string_view suffix) {
  for (int i = 0; i < NUM_SUFFIXES; i++) {
    if (SUFFIXES[i] == suffix) return i;
  }
  return -1;
}

std::string Guitar::ChordString(Chord c) {
  const auto [base, suf] = UnChord(c);
  CHECK(base >= 0 && base < Guitar::NUM_BASES) << "Invalid chord " << c;
  CHECK(suf >= 0 && suf < Guitar::NUM_SUFFIXES) << "Invalid chord " << suf;
  return (string)BASES[base] + (string)SUFFIXES[suf];
}

std::string Guitar::FingeringString(Fingering fing) {
  const auto [a, b, c, d, e, f] = fing;
  auto Char = [](int x) -> char {
      if (x < 0) return 'x';
      if (x <= 9) return '0' + x;
      return 'a' + (x - 10);
    };
  char ret[7];
  ret[0] = Char(a);
  ret[1] = Char(b);
  ret[2] = Char(c);
  ret[3] = Char(d);
  ret[4] = Char(e);
  ret[5] = Char(f);
  ret[6] = 0;
  return &ret[0];
}

std::optional<Guitar::Chord> Guitar::Parse(std::string_view sv) {
  string s = NormalizeBase((string)sv);

  // Longer matches have to come first here, since
  // we use a totally greedy strategy!
  for (string_view pfx : { "C#"sv, "C"sv, "D"sv, "Eb"sv,
	"E"sv, "F#"sv, "F"sv, "G"sv, "Ab"sv, "A"sv, "Bb"sv, "B"sv }) {
    if (Util::TryStripPrefix(pfx, &s)) {
      // Matched.
      const int base_num = BaseNum(pfx);
      s = NormalizeSuffix(s);
      const int suffix_num = SuffixNum(s);
      // Invalid. (Note: Shouldn't continue looping since we've modified s.)
      if (base_num < 0 || suffix_num < 0) return {};
      const Chord c = ChordOfUnchecked(base_num, suffix_num);
      return {c};
    }
  }
  
  // No match for base.
  return {};  
}

// int8_t packed into lowest 6 bytes.
using PackedFingering = uint64_t;
static constexpr Guitar::Fingering Unpack(PackedFingering pf) {
  return make_tuple((int)(int8_t)(255 & (pf >> (5 * 8))),
		    (int)(int8_t)(255 & (pf >> (4 * 8))),
		    (int)(int8_t)(255 & (pf >> (3 * 8))),
		    (int)(int8_t)(255 & (pf >> (2 * 8))),
		    (int)(int8_t)(255 & (pf >> (1 * 8))),
		    (int)(int8_t)(255 & (pf >> (0 * 8))));
}

static constexpr PackedFingering Pack(Guitar::Fingering f) {
  return
    ((255 & (uint64_t)(int8_t)(std::get<0>(f))) << (5 * 8)) |
    ((255 & (uint64_t)(int8_t)(std::get<1>(f))) << (4 * 8)) |
    ((255 & (uint64_t)(int8_t)(std::get<2>(f))) << (3 * 8)) |
    ((255 & (uint64_t)(int8_t)(std::get<3>(f))) << (2 * 8)) |
    ((255 & (uint64_t)(int8_t)(std::get<4>(f))) << (1 * 8)) |
    ((255 & (uint64_t)(int8_t)(std::get<5>(f))) << (0 * 8));
}

// Sanity check the above for -1 especially.
static_assert(Unpack(Pack(make_tuple(-1, 3, 2, -1, 1, 0))) ==
	      make_tuple(-1, 3, 2, -1, 1, 0));

namespace {
// Singleton parsed database. Depends on DATA symbol generated by
// gencc.
struct DB {
  DB() {
    data.resize(Guitar::NUM_BASES);
    int idx = 0;
    auto GetNum = [&idx]() { return CharNum(DATA[idx++]); };
    const int bases_in_data = GetNum();
    CHECK_EQ(bases_in_data, Guitar::NUM_BASES) << "Expected to be dense.";

    [[maybe_unused]] int ambiguous = 0;
    for (int b = 0; b < Guitar::NUM_BASES; b++) {
      // Not guaranteed to be in the same order.
      // This will be the index into the vector.
      const int base = GetNum();
      std::unordered_map<int, vector<PackedFingering>> &base_row = data[base];
      
      const int nsuf = GetNum();
      for (int s = 0; s < nsuf; s++) {
	// Suffix code (key into map).
	const int suffix = GetNum();
	vector<PackedFingering> &fingerings = base_row[suffix];

	const Guitar::Chord chord = ChordOfUnchecked(base, suffix);
	
	// Number of fingerings.
	const int nfing = GetNum();
	for (int f = 0; f < nfing; f++) {
	  // Each is encoded +1 so that -1 is nonnegative.
	  const int f0 = GetNum() - 1;
	  const int f1 = GetNum() - 1;
	  const int f2 = GetNum() - 1;
	  const int f3 = GetNum() - 1;
	  const int f4 = GetNum() - 1;
	  const int f5 = GetNum() - 1;
	  const Guitar::Fingering fingering =
	    make_tuple(f0, f1, f2, f3, f4, f5);
	  const PackedFingering pf = Pack(fingering);
	  fingerings.push_back(pf);
	  // There are some ambiguous fingerings in the upstream data, so we just
	  // keep the first one we saw.
	  [[maybe_unused]] bool inserted = rev.emplace(pf, chord).second;
	  #ifdef DEBUG_GUITAR
	  if (!inserted) {
	    ambiguous++;
	    /*
	    LOG(ERROR) <<
	    "duplicate fingering: " <<
	    Guitar::FingeringString(fingering) <<
	    "\nfor: " << Guitar::ChordString(chord) <<
	    "\nand existing: " << Guitar::ChordString(rev[pf]);
	    */
	    printf("%s for %s and %s\n",
		   Guitar::FingeringString(fingering).c_str(),
		   Guitar::ChordString(chord).c_str(),
		   Guitar::ChordString(rev[pf]).c_str());
	  }
	  #endif
	}
      }
    }
    #ifdef DEBUG_GUITAR
    printf("There are %d ambiguous fingerings!!\n", ambiguous);
    #endif
    
    // sizeof DATA includes nul terminating byte.
    CHECK_EQ(idx + 1, sizeof DATA) << (idx + 1) << " " << (sizeof DATA);
  }

  // Outer vector is base chords, dense.
  // Then suffix, then each known fingering.
  vector<std::unordered_map<int, vector<PackedFingering>>> data;
  // PERF: These data structures don't depend on each other, so
  // we could perhaps only load the one we need (for embedded
  // applications that only call GetFingerings xor NameFingering).
  std::unordered_map<PackedFingering, Guitar::Chord> rev;
};
}

static const DB *GetDB() {
  static const DB *db = new DB;
  return db;
}

std::vector<Guitar::Fingering> Guitar::GetFingerings(Chord c) {
  const DB &db = *GetDB();

  const auto [base, suf] = UnChord(c);
  CHECK(base >= 0 && base < Guitar::NUM_BASES) << "Invalid chord " << c;
  CHECK(suf >= 0 && suf < Guitar::NUM_SUFFIXES) << "Invalid chord " << suf;
  const auto &m = db.data[base];
  auto sit = m.find(suf);
  // No fingerings known.
  if (sit == m.end()) return {};
  // Convert to external representation.
  vector<Fingering> ret;
  ret.reserve(sit->second.size());
  for (const PackedFingering pf : sit->second)
    ret.push_back(Unpack(pf));
  return ret;
}

std::optional<Guitar::Chord> Guitar::NameFingering(Fingering f) {
  const DB &db = *GetDB();

  PackedFingering packed = Pack(f);
  auto it = db.rev.find(packed);
  if (it == db.rev.end()) return {};
  return {it->second};
}
