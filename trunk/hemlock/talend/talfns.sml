
(* holds tal functions that should be in every cord *)
structure TALFns =
struct

    structure TU = TALUtil
    val newstring = HemlockUtil.newstring "__"
    val itos = Int.toString


    val unboxsv = newstring "unboxsv"
    val boxsv = newstring "boxsv"
    val array0 = newstring "array0"
    val spawn = newstring "spawn"
    val umvec = newstring "umvec"
    val getwitvec = newstring "getwitvec"
    val concat = newstring "concat"

    val errorstring = newstring "errorstring"

    fun concat_code () =
        (concat, nil,
         "?str",
         ["(?arr ?str)",
          TAL.typeof "newstring"],
         [
          "   MOV EAX,[ESP+4]",
          "   UNPACK ?sz$3,EAX,EAX",
          "   PUSH DWORD PTR subsume(<B4>,[EAX])",
          "   PUSH subsume(<B4>,0)",
          "   PUSH subsume(<B4>,0)",
          "   JMP concatfortest$4",
          "concatforbody$5:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::(?S ?str (?arr ?str)::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   PUSH DWORD PTR [ESP+4]",
          "   MOV EBX,[ESP+20]",
          "   MOV EAX,[ESP+4]",
          "   UNPACK ?sz$8,EBX,EBX",
          "   UNPACK i$9,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 0x1287 "array bounds",
          "   MOV EBX,[EBX+4]",
          "   MOV EAX,[EBX+4*EAX]",
          "   UNPACK ?sz$10,EAX,EAX",
          "   MOV EAX,subsume(<B4>,[EAX])",
          "   POP EBX",
          "   ADD EAX,EBX",
          "   MOV [ESP+4],EAX",
          "concatforcount$6:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "concatfortest$4:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,[ESP+8]",
          "   CMP EBX,EAX",
          "   JL tapp(concatforbody$5,<s1,s2,e1,e2>)",
          "concatforend$7:",
          "   ADD ESP,4",
          "   PUSH DWORD PTR [ESP]",
          "   MOV EAX,[ESP+20]",
          "   CALL tapp(EAX,<ESP 1 6 s1,EBP 1,e1,e2>)",
          "   MOV [ESP],EAX",
          "   PUSH subsume(<B4>,0)",
          "   PUSH subsume(<B4>,0)",
          "   JMP concatfortest$11",
          "concatforbody$12:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::?str::B4::B4::(?S ?str (?arr ?str)::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   MOV EBX,[ESP+24]",
          "   MOV EAX,[ESP]",
          "   UNPACK ?sz$15,EBX,EBX",
          "   UNPACK i$16,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 0x2596 "array bounds",
          "   MOV EBX,[EBX+4]",
          "   PUSH DWORD PTR [EBX+4*EAX]",
          "   PUSH subsume(<B4>,0)",
          "   JMP concatfortest$17",
          "concatforbody$18:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::?str::B4::B4::?str::B4::B4::(?S ?str (?arr ?str)::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   PUSH DWORD PTR [ESP+16]",
          "   PUSH DWORD PTR [ESP+16]",
          "   MOV EBX,[ESP+12]",
          "   MOV EAX,[ESP+8]",
          "   UNPACK ?sz$21,EBX,EBX",
          "   UNPACK i$22,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 0x3305 "array bounds",
          "   MOV EBX,[EBX+4]",
          "   MOV ECX,EAX",
          "   MOV EAX,0",
          "   MOV AL,[EBX+ECX]",
          "   POP EDI",
          "   POP ESI",
          "   UNPACK ?sz$23,ESI,ESI",
          "   UNPACK i$24,EDI,EDI",
          "   CMP EDI,[ESI]",
          "   JAE " ^ TALUtil.error 0x3565 "array bounds",
          "   MOV ESI,[ESI+4]",
          "   MOV [ESI+EDI],AL",
          "   MOV EBX,[ESP+12]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP+12],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "concatforcount$19:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "concatfortest$17:",
          "   PUSH DWORD PTR [ESP]",
          "   MOV EAX,[ESP+8]",
          "   UNPACK ?sz$25,EAX,EAX",
          "   MOV EAX,subsume(<B4>,[EAX])",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JL tapp(concatforbody$18,<s1,s2,e1,e2>)",
          "concatforend$20:",
          "   ADD ESP,8",
          "concatforcount$13:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "concatfortest$11:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,[ESP+16]",
          "   CMP EBX,EAX",
          "   JL tapp(concatforbody$12,<s1,s2,e1,e2>)",
          "concatforend$14:",
          "   ADD ESP,4",
          "   MOV EAX,[ESP+4]",
          "   ADD ESP,16",
          "   RETN"])

    fun getwitvec_code () =
        (getwitvec, nil,
         "(?arr ?str)",
         ["(?arr ?str)",
          "?str",
          TAL.typeof "newarray",
          TAL.typeof "newstring"],
         [
          "   PUSH " ^ errorstring,
          "   MOV EAX,[ESP+8]",
          "   UNPACK ?sz$5,EAX,EAX",
          "   PUSH DWORD PTR subsume(<B4>,[EAX])",
          "   MOV EAX,[ESP+20]",
          "   CALL tapp(EAX,<?str,ESP 2 7 s1,EBP 1,e1,e2>)",
          "   ADD ESP,4",
          "   MOV [ESP],EAX",
          "   PUSH subsume(<B4>,0)",
          "   JMP gwvfortest$6",
          "gwvforbody$7:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   MOV EBX,[ESP+12]",
          "   MOV EAX,[ESP]",
          "   UNPACK ?sz$10,EBX,EBX",
          "   UNPACK i$11,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 1719 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   PUSH DWORD PTR [EBX+4*EAX]",
          "   PUSH subsume(<B4>,1)",
          "   MOV EAX,[ESP+24]",
          "   UNPACK ?sz$12,EAX,EAX",
          "   PUSH DWORD PTR subsume(<B4>,[EAX])",
          "   PUSH subsume(<B4>,0)",
          "   PUSH subsume(<B4>,0)",
          "   PUSH subsume(<B4>,0)",
          "   JMP gwvfortest$13",
          "gwvforbody$14:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   MOV EAX,[ESP+16]",
          "   CMP EAX,1",
          "   JNE gwvl1$18",
          "   MOV EBX,[ESP+40]",
          "   MOV EAX,[ESP]",
          "   UNPACK ?sz$22,EBX,EBX",
          "   UNPACK i$23,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 2923 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   MOV ECX,EAX",
          "   MOV EAX,0",
          "   MOV AL,[EBX+ECX]",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,35)",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JNE gwviffalse$20",
          "gwviftrue$19:",
          "   MOV EAX,subsume(<B4>,2)",
          "   MOV [ESP+16],EAX",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP+8],EAX",
          "   JMP gwvifend$21",
          "gwviffalse$20:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "gwvtc_fast$24:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   JMP gwvforend$16",
          "gwvifend$21:",
          "   JMP tapp(endgwvswitch$17,<s1,s2,e1,e2>)",
          "gwvl1$18:",
          "   CMP EAX,2",
          "   JNE gwvl2$25",
          "   MOV EBX,[ESP+40]",
          "   MOV EAX,[ESP]",
          "   UNPACK ?sz$29,EBX,EBX",
          "   UNPACK i$30,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 4453 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   MOV ECX,EAX",
          "   MOV EAX,0",
          "   MOV AL,[EBX+ECX]",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,61)",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JNE gwviffalse$27",
          "gwviftrue$26:",
          "   PUSH DWORD PTR [ESP]",
          "   MOV EAX,[ESP+12]",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "   PUSH EAX",
          "   MOV EAX,[ESP+24]",
          "   UNPACK ?sz$34,EAX,EAX",
          "   MOV EAX,subsume(<B4>,[EAX])",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JNE gwviffalse$32",
          "gwviftrue$31:",
          "   PUSH subsume(<B4>,1)",
          "   PUSH subsume(<B4>,0)",
          "   JMP gwvfortest$35",
          "gwvforbody$36:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   MOV EBX,[ESP+28]",
          "   MOV EAX,[ESP]",
          "   UNPACK ?sz$42,EBX,EBX",
          "   UNPACK i$43,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 5981 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   MOV ECX,EAX",
          "   MOV EAX,0",
          "   MOV AL,[EBX+ECX]",
          "   PUSH EAX",
          "   PUSH DWORD PTR [ESP+52]",
          "   MOV EBX,[ESP+24]",
          "   MOV EAX,[ESP+8]",
          "   ADD EAX,EBX",
          "   POP EBX",
          "   UNPACK ?sz$44,EBX,EBX",
          "   UNPACK i$45,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 6442 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   MOV ECX,EAX",
          "   MOV EAX,0",
          "   MOV AL,[EBX+ECX]",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JE gwviffalse$40",
          "gwviftrue$39:",
          "   MOV EAX,subsume(<B4>,0)",
          "   MOV [ESP+4],EAX",
          "   JMP gwvforend$38",
          "gwviffalse$40:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "gwvtc_fast$46:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "gwvifend$41:",
          "gwvforcount$37:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "gwvfortest$35:",
          "   PUSH DWORD PTR [ESP]",
          "   MOV EAX,[ESP+32]",
          "   UNPACK ?sz$47,EAX,EAX",
          "   MOV EAX,subsume(<B4>,[EAX])",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JL tapp(gwvforbody$36,<s1,s2,e1,e2>)",
          "gwvforend$38:",
          "   ADD ESP,4",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,1)",
          "   CMP EBX,EAX",
          "   JNE gwviffalse$49",
          "gwviftrue$48:",
          "   MOV EAX,subsume(<B4>,4)",
          "   MOV [ESP+20],EAX",
          "   MOV EBX,[ESP+4]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP+12],EAX",
          "   MOV EAX,subsume(<B4>,0)",
          "   MOV [ESP+8],EAX",
          "   JMP gwvifend$50",
          "gwviffalse$49:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "gwvtc_fast$51:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   MOV EAX,subsume(<B4>,3)",
          "   MOV [ESP+20],EAX",
          "gwvifend$50:",
          "   ADD ESP,4",
          "   JMP gwvifend$33",
          "gwviffalse$32:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "gwvtc_fast$52:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   MOV EAX,subsume(<B4>,3)",
          "   MOV [ESP+16],EAX",
          "gwvifend$33:",
          "   JMP gwvifend$28",
          "gwviffalse$27:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "gwvtc_fast$53:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "gwvifend$28:",
          "   JMP tapp(endgwvswitch$17,<s1,s2,e1,e2>)",
          "gwvl2$25:",
          "   CMP EAX,4",
          "   JNE gwvl4$54",
          "   PUSH subsume(<B4>,0)",
          "   MOV EBX,[ESP+44]",
          "   MOV EAX,[ESP+4]",
          "   UNPACK ?sz$58,EBX,EBX",
          "   UNPACK i$59,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 10933 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   MOV ECX,EAX",
          "   MOV EAX,0",
          "   MOV AL,[EBX+ECX]",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,92)",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JNE gwviffalse$56",
          "gwviftrue$55:",
          "   MOV EBX,[ESP+4]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP+4],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   MOV [ESP],EAX",
          "   JMP gwvifend$57",
          "gwviffalse$56:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "gwvtc_fast$60:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "gwvifend$57:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,0)",
          "   CMP EBX,EAX",
          "   JNE gwvcondfalse$64",
          "gwvcondtrue$65:",
          "   MOV EBX,[ESP+44]",
          "   MOV EAX,[ESP+4]",
          "   UNPACK ?sz$66,EBX,EBX",
          "   UNPACK i$67,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 12584 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   MOV ECX,EAX",
          "   MOV EAX,0",
          "   MOV AL,[EBX+ECX]",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,44)",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JE gwviftrue$61",
          "gwvcondfalse$64:",
          "   PUSH DWORD PTR [ESP+4]",
          "   PUSH DWORD PTR [ESP+20]",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JNE gwviffalse$62",
          "gwviftrue$61:",
          "   PUSH DWORD PTR [ESP+4]",
          "   PUSH DWORD PTR [ESP+20]",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JNE gwviffalse$69",
          "gwviftrue$68:",
          "   MOV EBX,[ESP+8]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP+8],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "   JMP gwvifend$70",
          "gwviffalse$69:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "gwvtc_fast$71:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "gwvifend$70:",
          "   PUSH DWORD PTR [ESP+32]",
          "   PUSH DWORD PTR [ESP+32]",
          "   PUSH DWORD PTR [ESP+16]",
          "   MOV EAX,[ESP+64]",
          "   CALL tapp(EAX,<ESP 1 17 s1,EBP 1,e1,e2>)",
          "   ADD ESP,4",
          "   POP EDI",
          "   POP ESI",
          "   UNPACK ?sz$72,ESI,ESI",
          "   UNPACK i$73,EDI,EDI",
          "   CMP EDI,[ESI]",
          "   JAE " ^ TALUtil.error 14794 "ArrayBounds",
          "   MOV ESI,[ESI+4]",
          "   MOV [ESI+4*EDI],EAX",
          "   PUSH DWORD PTR [ESP+12]",
          "   PUSH subsume(<B4>,0)",
          "   JMP gwvfortest$74",
          "gwvforbody$75:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   MOV EBX,[ESP+52]",
          "   MOV EAX,[ESP+4]",
          "   UNPACK ?sz$81,EBX,EBX",
          "   UNPACK i$82,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 15725 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   MOV ECX,EAX",
          "   MOV EAX,0",
          "   MOV AL,[EBX+ECX]",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,92)",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JNE gwviffalse$79",
          "gwviftrue$78:",
          "   MOV EBX,[ESP+4]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP+4],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "   JMP gwvifend$80",
          "gwviffalse$79:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "gwvtc_fast$83:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "gwvifend$80:",
          "   MOV EBX,[ESP+40]",
          "   MOV EAX,[ESP+36]",
          "   UNPACK ?sz$84,EBX,EBX",
          "   UNPACK i$85,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 17152 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   PUSH DWORD PTR [EBX+4*EAX]",
          "   PUSH DWORD PTR [ESP+4]",
          "   MOV EBX,[ESP+60]",
          "   MOV EAX,[ESP+12]",
          "   UNPACK ?sz$86,EBX,EBX",
          "   UNPACK i$87,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 17493 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   MOV ECX,EAX",
          "   MOV EAX,0",
          "   MOV AL,[EBX+ECX]",
          "   POP EDI",
          "   POP ESI",
          "   UNPACK ?sz$88,ESI,ESI",
          "   UNPACK i$89,EDI,EDI",
          "   CMP EDI,[ESI]",
          "   JAE " ^ TALUtil.error 17821 "ArrayBounds",
          "   MOV ESI,[ESI+4]",
          "   MOV [ESI+EDI],AL",
          "   MOV EBX,[ESP+4]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP+4],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "gwvforcount$76:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "gwvfortest$74:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,[ESP+16]",
          "   CMP EBX,EAX",
          "   JL tapp(gwvforbody$75,<s1,s2,e1,e2>)",
          "gwvforend$77:",
          "   ADD ESP,12",
          "   JMP gwvforend$16",
          "gwviffalse$62:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "gwvtc_fast$90:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   MOV EBX,[ESP+8]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP+8],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "gwvifend$63:",
          "   ADD ESP,4",
          "   JMP tapp(endgwvswitch$17,<s1,s2,e1,e2>)",
          "gwvl4$54:",
          "   CMP EAX,3",
          "   JNE gwvl3$91",
          "   MOV EBX,[ESP+40]",
          "   MOV EAX,[ESP]",
          "   UNPACK ?sz$95,EBX,EBX",
          "   UNPACK i$96,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 19918 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   MOV ECX,EAX",
          "   MOV EAX,0",
          "   MOV AL,[EBX+ECX]",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,92)",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JNE gwviffalse$93",
          "gwviftrue$92:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "   JMP gwvifend$94",
          "gwviffalse$93:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "gwvtc_fast$97:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   MOV EBX,[ESP+40]",
          "   MOV EAX,[ESP]",
          "   UNPACK ?sz$101,EBX,EBX",
          "   UNPACK i$102,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 21302 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   MOV ECX,EAX",
          "   MOV EAX,0",
          "   MOV AL,[EBX+ECX]",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,44)",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JNE gwviffalse$99",
          "gwviftrue$98:",
          "   MOV EAX,subsume(<B4>,1)",
          "   MOV [ESP+16],EAX",
          "   JMP gwvifend$100",
          "gwviffalse$99:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "gwvtc_fast$103:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "gwvifend$100:",
          "gwvifend$94:",
          "   JMP tapp(endgwvswitch$17,<s1,s2,e1,e2>)",
          "gwvl3$91:",
          "   MOV EAX,subsume(<B4>,1)",
          "   MOV [ESP+16],EAX",
          "   FALLTHRU <s1,s2,e1,e2>",
          "endgwvswitch$17:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::B4::B4::B4::B4::?str::B4::(?arr ?str)::(?S (?arr ?str) (?arr ?str)::?str::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "gwvforcount$15:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "gwvfortest$13:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,[ESP+12]",
          "   CMP EBX,EAX",
          "   JL tapp(gwvforbody$14,<s1,s2,e1,e2>)",
          "gwvforend$16:",
          "   ADD ESP,24",
          "gwvforcount$8:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "gwvfortest$6:",
          "   PUSH DWORD PTR [ESP]",
          "   MOV EAX,[ESP+16]",
          "   UNPACK ?sz$104,EAX,EAX",
          "   MOV EAX,subsume(<B4>,[EAX])",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JL tapp(gwvforbody$7,<s1,s2,e1,e2>)",
          "gwvforend$9:",
          "   ADD ESP,4",
          "   POP EAX",
          "   RETN"])


    fun umvec_code() =
        (umvec, nil,
         "(`ttt)",
         [TAL.typeof "newarray", TAL.typeof "newstring",
          "(?arr `ttt)"],
         [
          "   MOV EAX,[ESP+12]",
          "   UNPACK ?sz$3,EAX,EAX",
          "   PUSH DWORD PTR subsume(<B4>,[EAX])",
          "   MALLOC mptr$4,8",
          "   MOV ESI,EAX",
          "   MOV DWORD PTR [ESI],1",
          "   MOV EAX,subsume(<B4>,0)",
          "   MOV [ESI+4],EAX",
          "   FORGETUNIQUE mptr$4",
          "   PUSH rollsum(<`ttt>,forgetname(ESI))",
          "   PUSH DWORD PTR [ESP]",
          "   MOV EAX,[ESP+24]",
          "   UNPACK ?sz$5,EAX,EAX",
          "   PUSH DWORD PTR subsume(<B4>,[EAX])",
          "   MOV EAX,[ESP+20]",
          "   CALL tapp(EAX,<`ttt,ESP 2 8 s1,EBP 1,e1,e2>)",
          "   ADD ESP,4",
          "   MOV [ESP],EAX",
          "   PUSH subsume(<B4>,0)",
          "   JMP umvfortest$6",

          "umvforbody$7:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::(?arr `ttt)::`ttt::B4::(?S `ttt (All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str B4::se s1 s2 e1 e2)#(?E s2 e2)})::(?arr `ttt)::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   PUSH DWORD PTR [ESP+4]",
          "   PUSH DWORD PTR [ESP+4]",
          "   PUSH DWORD PTR [ESP+28]",
          "   PUSH DWORD PTR [ESP+36]",
          "   MOV EBX,[ESP+44]",
          "   MOV EAX,[ESP+16]",
          "   UNPACK ?sz$10,EBX,EBX",
          "   UNPACK i$11,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 2095 "ArrayBounds",
          "   MOV EBX,[EBX+4]",
          "   MOV EAX,unroll([EBX+4*EAX])",
          "   NAMEOBJ uptr$13,EAX",
          "   MOV ECX,[EAX]",
          "   CMP ECX," ^ itos (TAL.tagfor RTL.STRING),
          "   JNE " ^ TALUtil.error 2262 "UnionVariant",
          "   COERCE forgetname(EAX)",
          "   REMOVENAME uptr$13",
          "   PUSH DWORD PTR [rec(EAX)+4]",
          "   PUSH DWORD PTR [ESP]",
          "   PUSH DWORD PTR [ESP+8]",
          "   PUSH DWORD PTR [ESP+16]",
          "   CALL tapp(" ^ TALMarshall.unmarshall ^ ",<ESP 3 16 s1,EBP 1,e1,e2>)",
          "   ADD ESP,24",
          "   POP EDI",
          "   POP ESI",
          "   UNPACK ?sz$14,ESI,ESI",
          "   UNPACK i$15,EDI,EDI",
          "   CMP EDI,[ESI]",
          "   JAE " ^ TALUtil.error 2755 "ArrayBounds",
          "   MOV ESI,[ESI+4]",
          "   MOV [ESI+4*EDI],EAX",
          "umvforcount$8:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "umvfortest$6:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,[ESP+12]",
          "   CMP EBX,EAX",
          "   JL tapp(umvforbody$7,<s1,s2,e1,e2>)",
          "umvforend$9:",
          "   ADD ESP,4",
          (* make a ttt *)
          "   MALLOC mptr$16,8",
          "   MOV ESI,EAX",
          "   MOV DWORD PTR [ESI]," ^ itos TAL.TUPLETAG,
          "   MOV EAX,[ESP]",
          "   MOV [ESI+4],EAX",
          "   FORGETUNIQUE mptr$16",
          "   MOV EAX,rollsum(<`ttt>,forgetname(ESI))",
          "   ADD ESP,12",
          "   RETN"])

    fun boxsv_code () =
        (boxsv, nil,
         "(`ttt)",
         ["(?arr ?str)",
          (* new_array *)
          "(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2]," ^
          "EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#" ^
          "(?E s2 e2)})"],
         ["   MOV EAX,[ESP+4]",
          "   UNPACK ?sz$3,EAX,EAX",
          "   PUSH DWORD PTR subsume(<B4>,[EAX])",
          "   SUB ESP,4",
          "   MOV EBX,[ESP+4]",
          "   MOV EAX,subsume(<B4>,0)",
          "   CMP EBX,EAX",
          "   JNE ifbsvfalse$5",
          "ifbsvtrue$4:",
          "   MALLOC m$7,0,<[]>",
          "   MOV ESI,EAX",
          "   MALLOC r$8,8,<[:4,:4]>",
          "   MOV DWORD PTR [EAX],0",
          "   FORGETUNIQUE m$7",
          "   MOV [EAX+4],array(0,0,<`ttt^rw>,forgetname(ESI))",
          "   FORGETUNIQUE r$8",
          "   COERCE pack(<0>,forgetname(EAX),<?arr `ttt>)",
          "   MOV [ESP],EAX",
          "   JMP ifbsvbsvend$6",
          "ifbsvfalse$5:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "tc_bsvfast$9:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr junk4::B4::(?S `ttt (?arr ?str)::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   MALLOC boxsv_mptr$10,8",
          "   MOV ESI,EAX",
          "   MOV DWORD PTR [ESI]," ^ itos (TAL.tagfor RTL.STRING),
          "   MOV EBX,[ESP+12]",
          "   MOV EAX,subsume(<B4>,0)",
          "   UNPACK ?sz$11,EBX,EBX",
          "   UNPACK i$12,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 0x1715 "array bounds",
          "   MOV EBX,[EBX+4]",
          "   MOV EAX,[EBX+4*EAX]",
          "   MOV [ESI+4],EAX",
          "   FORGETUNIQUE boxsv_mptr$10",
          "   PUSH rollsum(<`ttt>,forgetname(ESI))",
          "   PUSH DWORD PTR [ESP+8]",
          "   MOV EAX,[ESP+24]",
          "   CALL tapp(EAX,<`ttt,ESP 2 7 s1,EBP 1,e1,e2>)",
          "   ADD ESP,8",
          "   MOV [ESP],EAX",
          "   JMP whilebsvtest$14",
          "whilebsvbody$13:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?arr `ttt)::B4::(?S `ttt (?arr ?str)::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   PUSH DWORD PTR [ESP]",
          "   PUSH DWORD PTR [ESP+8]",
          "   MALLOC boxsv_mptr$16,8",
          "   MOV ESI,EAX",
          "   MOV DWORD PTR [ESI]," ^ itos (TAL.tagfor RTL.STRING),
          "   MOV EBX,[ESP+20]",
          "   MOV EAX,[ESP+12]",
          "   UNPACK ?sz$17,EBX,EBX",
          "   UNPACK i$18,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 0x2716 "array bounds",
          "   MOV EBX,[EBX+4]",
          "   MOV EAX,[EBX+4*EAX]",
          "   MOV [ESI+4],EAX",
          "   FORGETUNIQUE boxsv_mptr$16",
          "   MOV EAX,rollsum(<`ttt>,forgetname(ESI))",
          "   POP EDI",
          "   POP ESI",
          "   UNPACK ?sz$19,ESI,ESI",
          "   UNPACK i$20,EDI,EDI",
          "   CMP EDI,[ESI]",
          "   JAE " ^ TALUtil.error 0x3044 "array bounds",
          "   MOV ESI,[ESI+4]",
          "   MOV [ESI+4*EDI],EAX",
          "whilebsvtest$14:",
          "   PUSH DWORD PTR [ESP+4]",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "   MOV [ESP+4],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   POP EBX",
          "   ADD EAX,EBX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,0)",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JNE tapp(whilebsvbody$13,<s1,s2,e1,e2>)",
          "whilebsvend$15:",
          "ifbsvbsvend$6:",
          "   MALLOC boxsv_mptr$21,8",
          "   MOV ESI,EAX",
          "   MOV DWORD PTR [ESI]," ^ itos (TAL.TUPLETAG),
          "   MOV EAX,[ESP]",
          "   MOV [ESI+4],EAX",
          "   FORGETUNIQUE boxsv_mptr$21",
          "   MOV EAX,rollsum(<`ttt>,forgetname(ESI))",
          "   ADD ESP,8",
          "RETN"])

    fun unboxsv_code () =
        (unboxsv, nil,
         "(?arr ?str)",
         [(* unboxed array of boxed *)
          "(?arr `ttt)",
          (* new_array *)
          "(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2]," ^
          "EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#" ^
          "(?E s2 e2)})"],
         ["   MOV EAX,[ESP+4]",
          "   UNPACK ?sz$3,EAX,EAX",
          "   PUSH DWORD PTR subsume(<B4>,[EAX])",
          "   MOV EBX,[ESP]",
          (* is size 0? *)
          "   MOV EAX,subsume(<B4>,0)",
          "   CMP EBX,EAX",
          "   JNE iffalse$5",

          (* yeah, return empty array. *)
          "iftrue$4:",
          "   MALLOC m$7,0,<[]>",
          "   MOV ESI,EAX",
          "   MALLOC r$8,8,<[:4,:4]>",
          "   MOV DWORD PTR [EAX],0",
          "   FORGETUNIQUE m$7",
          "   MOV [EAX+4],array(0,0,<?str^rw>,forgetname(ESI))",
          "   FORGETUNIQUE r$8",
          "   COERCE pack(<0>,forgetname(EAX),<?arr ?str>)",
          "   ADD ESP,4",
          "   RETN",

          (* no, do unboxing. *)
          "iffalse$5:",
          "   FALLTHRU <s1,s2,e1,e2>",
          "tc_fast$9:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::(?S (?arr ?str) (?arr `ttt)::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   PUSH DWORD PTR [ESP+12]",
          "   PUSH DWORD PTR [ESP+4]",
          "   MOV EBX,[ESP+16]",
          "   MOV EAX,subsume(<B4>,0)",
          "   UNPACK ?sz$10,EBX,EBX",
          "   UNPACK i$11,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 0x1942 "array bounds",
          "   MOV EBX,[EBX+4]",
          "   MOV EAX,unroll([EBX+4*EAX])",
          "   NAMEOBJ uptr$13,EAX",
          "   MOV ECX,[EAX]",
          "   CMP ECX," ^ itos (TAL.tagfor RTL.STRING),
          "   JNE " ^ TALUtil.error 0x2171 "not string",
          "   COERCE forgetname(EAX)",
          "   REMOVENAME uptr$13",
          "   PUSH DWORD PTR [rec(EAX)+4]",
          "   PUSH DWORD PTR [ESP]",
          "   PUSH DWORD PTR [ESP+8]",
          "   CALL DWORD PTR tapp([ESP+16],<?str,ESP 2 9 s1,EBP 1,e1,e2>)",
          "   ADD ESP,16",
          "   MOV [ESP],EAX",
          "   JMP whiletest$15",
          "whilebody$14:",
          "LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?arr ?str)::B4::(?S (?arr ?str) (?arr `ttt)::(All[va:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S (?arr va) B4::va::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   PUSH DWORD PTR [ESP]",
          "   PUSH DWORD PTR [ESP+8]",
          "   MOV EBX,[ESP+20]",
          "   MOV EAX,[ESP+12]",
          "   UNPACK ?sz$17,EBX,EBX",
          "   UNPACK i$18,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 0x3190 "array bounds",
          "   MOV EBX,[EBX+4]",
          "   MOV EAX,unroll([EBX+4*EAX])",
          "   NAMEOBJ uptr$20,EAX",
          "   MOV ECX,[EAX]",
          "   CMP ECX, " ^ itos (TAL.tagfor RTL.STRING),
          "   JNE " ^ TALUtil.error 0x3417 "not string",
          "   COERCE forgetname(EAX)",
          "   REMOVENAME uptr$20",
          "   MOV EAX,[rec(EAX)+4]",
          "   POP EDI",
          "   POP ESI",
          "   UNPACK ?sz$21,ESI,ESI",
          "   UNPACK i$22,EDI,EDI",
          "   CMP EDI,[ESI]",
          "   JAE " ^ TALUtil.error 0x3735 "array bounds",
          "   MOV ESI,[ESI+4]",
          "   MOV [ESI+4*EDI],EAX",
          "whiletest$15:",
          "   PUSH DWORD PTR [ESP+4]",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "   MOV [ESP+4],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   POP EBX",
          "   ADD EAX,EBX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,0)",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JNE tapp(whilebody$14,<s1,s2,e1,e2>)",
          "whileend$16:",
          "   MOV EAX,[ESP]",
          "   ADD ESP,8",
          "   RETN"])

    fun array0_code () =
        (array0, nil,
         "(?arr `ttt)",
         (* call with any argument *)
         ["B4"],
         TALUtil.indent
         ["MALLOC m$3,0,<[]>",
          "MOV ESI,EAX",
          "MALLOC r$4,8,<[:4,:4]>",
          "MOV DWORD PTR [EAX],0",
          "FORGETUNIQUE m$3",
          "MOV [EAX+4],array(0,0,<`ttt^rw>,forgetname(ESI))",
          "FORGETUNIQUE r$4",
          "COERCE pack(<0>,forgetname(EAX),<?arr `ttt>)",
          "RETN"])

    fun spawn_code () =
        (spawn,
         ["vdep:T4", "vdlis:T4"],
         "?str",
         ["?str", "(?arr ?str)",
          TAL.typeof "submit", TAL.typeof "dep_one",
          TAL.typeof "dep_and", TAL.typeof "deplist_empty",
          TAL.typeof "deplist_cons", "B4"],
         [
          "   PUSH DWORD PTR [ESP+24]",
          "   PUSH subsume(<B4>,0)",
          "   JMP spawn_fortest$3",
          "spawn_forbody$4:",
          "LABELTYPE <All[vdep:T4 vdlis:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr B4::vdlis::(?S ?str ?str::(?arr ?str)::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str ?str::vdep::(^T[0,1])::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S vdep ?str::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S vdep vdlis::se s1 s2 e1 e2)#(?E s2 e2)})::vdlis::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S vdlis vdep::vdlis::se s1 s2 e1 e2)#(?E s2 e2)})::B4::se s1 s2 e1 e2)#(?E s2 e2)}>",
          "   PUSH DWORD PTR [ESP+36]",
          "   MOV EBX,[ESP+20]",
          "   MOV EAX,[ESP+4]",
          "   UNPACK ?sz$7,EBX,EBX",
          "   UNPACK i$8,EAX,EAX",
          "   CMP EAX,[EBX]",
          "   JAE " ^ TALUtil.error 0x3735 "array bounds",
          "   MOV EBX,[EBX+4]",
          "   PUSH DWORD PTR [EBX+4*EAX]",
          "   MOV EAX,[ESP+32]",
          "   CALL tapp(EAX,<ESP 1 13 s1,EBP 1,e1,e2>)",
          "   MOV [ESP],EAX",
          "   PUSH DWORD PTR [ESP+12]",
          "   PUSH DWORD PTR [ESP]",
          "   PUSH DWORD PTR [ESP+8]",
          "   CALL DWORD PTR tapp([ESP+16],<ESP 2 16 s1,EBP 1,e1,e2>)",
          "   ADD ESP,20",
          "   MOV [ESP+4],EAX",
          "spawn_forcount$5:",
          "   MOV EBX,[ESP]",
          "   MOV EAX,subsume(<B4>,1)",
          "   ADD EAX,EBX",
          "   MOV [ESP],EAX",
          "   PUSH EAX",
          "   MOV EAX,subsume(<B4>,1)",
          "   SUB [ESP],EAX",
          "   POP EAX",
          "spawn_fortest$3:",
          "   PUSH DWORD PTR [ESP]",
          "   MOV EAX,[ESP+20]",
          "   UNPACK ?sz$9,EAX,EAX",
          "   MOV EAX,subsume(<B4>,[EAX])",
          "   POP EBX",
          "   CMP EBX,EAX",
          "   JL tapp(spawn_forbody$4,<vdep,vdlis,s1,s2,e1,e2>)",
          "spawn_forend$6:",
          "   ADD ESP,4",
          "   PUSH DWORD PTR [ESP+16]",
          "   PUSH DWORD PTR [ESP+12]",
          "   PUSH DWORD PTR [ESP+8]",
          "   MOV EAX,[ESP+36]",
          "   CALL tapp(EAX,<ESP 1 13 s1,EBP 1,e1,e2>)",
          "   MOV [ESP],EAX",
          "   PUSH DWORD PTR [ESP+48]",
          "   MOV EAX,subsume(<B4>,1)",
          "   MOV ECX,EAX",
          "   POP EBX",
          "   MOV EAX,sum(<^T[0,1]>,0)",
          "   CMP EBX,ECX",
          "   SETE AL",
          "   PUSH EAX",
          "   PUSH DWORD PTR [ESP]",
          "   PUSH DWORD PTR [ESP+8]",
          "   PUSH DWORD PTR [ESP+16]",
          "   CALL DWORD PTR tapp([ESP+24],<ESP 3 17 s1,EBP 1,e1,e2>)",
          "   ADD ESP,32",
          "   RETN"])



    fun code () = map TU.makecode [unboxsv_code, boxsv_code, array0_code,
                                   spawn_code, umvec_code, getwitvec_code,
                                   concat_code]


    val data = 
        [errorstring ^ "_data:",
         "LABELTYPE <^*[array(9,B1^rw)]>",
         "   COERCE array(0,0,<B1^rw>,?)",
         "   DB \"wit_error\"",
         errorstring ^ ":",
         "COERCE pack(<9>,?,<?str>)",
         "   DD 9",
         "   DD " ^ errorstring ^ "_data"]

end