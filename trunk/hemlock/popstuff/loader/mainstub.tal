; TAL IMPLEMENTATION mainstub
; This file was generated by TALC
	INCLUDE	TAL.INC
	_begin_TAL


	TAL_IMPORT	pop_runtime.tali
	TAL_IMPORT	mainstub_i.tali

	TAL_EXPORT	mainstub_e.tali

	TYPE	<bogus_option$1 :T4 = ^T[0]>

	CODE

;; useful for finding things you know are there but you don't know how
;; to write them: tal.ml: line ~500


;; standard popcorn type constructors

;; ?H (s:stack) cap => type of exception handler expecting exn in AX, stack at s.
;;      TYPE    <?H = fn s:Ts e:Tcap . code {cap: e,EAX: ?exn,ESP: sptr s}>

;; ?E (s:stack) cap => type of stack (s with exception handler at s on top of it)
;;      TYPE    <?E = fn s:Ts e:Tcap . (?H s e)::s>


;;      (     ) :: sp @ s1
;; ?S ret sp s1 s2 e1 e2 => type of stack with return address
;;                           (expects ret in EAX, ESP restored to args@s1)
;;      TYPE    <?S = fn ?ret:T4 ?sp:Ts ?s1:Ts ?s2:Ts ?e1:Tcap ?e2:Tcap . 
;;           (code {cap: &[?e1,?e2],
;;                  EAX: ?ret,
;;                  EBP: sptr (?E ?s2 ?e2),
;;                  ESP: sptr (?sp#?s1)#(?E ?s2 ?e2)})
;;           ::(?sp#?s1)>

;; for function of type uniii -> int
;; typical use is:
;;  EBP = ?E s2 e2
;;  ESP = (?S int uniii::se s1 s2 e1 e2)#(?E s2 e2)

;; in other words, ?S describes the type of the stack frame
;; which is (return address) :: args @ s1
;; which means there can be extra crap on the stack frame
;; between the args and EBP

;; my old code type: 
;; <(All[s:Ts e:Tcap] . 
;;    code { cap : e, 
;;           EBP : sptr (`ttt :: (code {cap: e, EAX: B4, EBP: sptr s, ESP: sptr s}) :: s), 
;;           ESP : sptr (`ttt :: (code {cap: e, EAX: B4, EBP: sptr s, ESP: sptr s}) :: s), 
;;           EBX: `ttt, ECX: `ttt, EDX: `ttt, ESI: `ttt, EDI: `ttt })>

;; that is, take ESP = EBP with the exception handler and "final return address" on top.

;; the only place I use EBP is in error handling (hemlock_runtime_error), which is
;; going to change anyway. So let's do it like this.
;; 

;; --- ESP ---
;; hemlock exn handler
;; return addr for main_fn
;; args to main_fn
;; ... any s1 ...
;; --- EBP ---
;; Pop exn handler
;; ... any s2 ...

;; This is basically _main_function's type, but with an extra ttt on top of ESP.

;; A side effect is that we can call any popcorn function directly, since we have a
;; EBP compatible with popcorn.


_main_function:
LABELTYPE <All[vanswer:T4 vdep:T4 vdlis:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S vanswer ?str::?str::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S vdep ?str::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S vdep vdlis::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S vdep vdlis::se s1 s2 e1 e2)#(?E s2 e2)})::vdlis::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S vdlis vdep::vdlis::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S vanswer ?str::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S vanswer ?str::se s1 s2 e1 e2)#(?E s2 e2)})::(All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S ?str ?str::vdep::(^T[0,1])::se s1 s2 e1 e2)#(?E s2 e2)})::se s1 s2 e1 e2)#(?E s2 e2)}>

	;; XXX FIXME  should load default exception handler!
	;; (we need some ttt there, so let's just put the int 32767 for now)
	MALLOC def_exn_handler__2, 8
	MOV DWORD PTR [EAX], 1
	MOV DWORD PTR [EAX + 4], subsume(<B4>, 32767)
	FORGETUNIQUE def_exn_handler__2
	COERCE rollsum(<`ttt>, forgetname(EAX))
	PUSH EAX
	;; put dummy ttt in each 
	MOV EBX, EAX
	MOV ECX, EAX
	MOV EDX, EAX
	MOV ESI, EAX
	MOV EDI, EAX

	;; note .. though we have pushed a ttt onto s1, hemcode knows this,
	;; so we don't need to pass it in here.
	JMP tapp(__hemlock_main, <vanswer, vdep, vdlis, s1, s2, e1, e2>)

;; this is the code for "PFinish," essentially:
;	ADD ESP,4

;        ; return bogus answer
;	PUSH	string_ref$4
;	MOV	EAX,[ESP+36]
;	CALL	tapp(EAX,<ESP 1 12 s1,EBP 1,e1,e2>)
;	ADD	ESP,4
;	RETN

__hemlock_main:
;; exported
LABELTYPE <All[vanswer:T4 vdep:T4 vdlis:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap] . (?hemcode vanswer vdep vdlis s1 s2 e1 e2)>
        SUB ESP, 4
        MALLOC asmall__1, 8
        MOV DWORD PTR [EAX], 1
        MOV DWORD PTR [EAX + 4], subsume(<B4>,99)
        FORGETUNIQUE asmall__1
        COERCE rollsum(<`ttt>, forgetname(EAX))
        MOV DWORD PTR [ESP], EAX
        ADD ESP, 4

	;; need to figure out this  -- coerce registers to junk or something
	MOV EBX,0
	MOV ECX,0
	MOV EDX,0
	MOV ESI,0
	MOV EDI,0

        JMP tapp(primop_unimplemented, <vanswer, vdep, vdlis, s1, s2, e1, e2>)

primop_unimplemented:
;; is B4 ok? is there a coercion from anything to B4? (perhaps not because of polymorphism)
;; the point here is that we don't know the state of our registers when we jump out,
;; so we want to allow them to be anything (Top). We don't use any of them but EBP, anyway.
;; (proper "top" type for a register is "junk4")
LABELTYPE <All[vanswer:T4 vdep:T4 vdlis:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap] . (?hemcodex (`ttt) (junk4) vanswer vdep vdlis s1 s2 e1 e2)>
        JMP hemlock_runtime_error

;; get popcorn exception handler and throw _NullPointer_pkt to it (we should make our own
;; nullary exception, really). I'm not sure what 'FINIT' does in this code. I copied it
;; from popcorn.
hemlock_runtime_error:
	MOV	EAX,DWORD PTR [_NullPointer_pkt]
	FINIT
	MOV	ESP,EBP
	POP	EBX
	JMP	EBX


_?NullPointer:
	MOV	EAX,DWORD PTR [_NullPointer_pkt]
	FINIT
	MOV	ESP,EBP
	POP	EBX
	JMP	EBX



	DATA

string$3:
LABELTYPE <^*[array(12,B1^rw)]>
COERCE	array(0,0,<B1^rw>,?)
	DB	"just kidding"
string_ref$4:
COERCE	pack(<12>,?,<?str>)
	DD	12
	DD	string$3

	_end_TAL
	END
