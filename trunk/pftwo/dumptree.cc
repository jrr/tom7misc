#include <algorithm>
#include <vector>
#include <string>
#include <set>
#include <memory>
#include <list>

#include <cstdio>
#include <cstdlib>

#include "pftwo.h"

#include "../fceulib/emulator.h"
#include "../fceulib/simplefm2.h"
#include "../cc-lib/util.h"

#include "atom7ic.h"
#include "weighted-objectives.h"
#include "headless-graphics.h"
#include "problem-twoplayer.h"
#include "treesearch.h"

#include "dumptree.h"

// XXX move to library?
static std::mutex print_mutex;
#define Printf(fmt, ...) do {			\
    MutexLock Printf_ml(&print_mutex);		\
    printf(fmt, ##__VA_ARGS__);			\
  } while (0)

// Dump the tree to the "tree" subdirectory as some HTML/JSON/PNGs.
// Your responsibility to clean this all up and deal with multiple
// versions being spit into the same dir.

static string Rtos(double d) {
  if (std::isnan(d)) return "NaN";
  char out[16];
  sprintf(out, "%.5f", d);
  char *o = out;
  while (*o == '0') o++;
  return string{o};
}

void TreeDumping::DumpTree(TreeSearch *search) {
  WriteMutexLock ml(&search->tree_m);  // PERF probably can be read?
  Printf("Dumping tree.");
  Util::MakeDir("tree");

  std::unique_ptr<Worker> tmp{search->problem->CreateWorker()};

  vector<int> expansion_cutoff;
  std::function<void(const Tree::Node *)> Count =
    [search, &expansion_cutoff, &Count](const Tree::Node *node) {
    if (node->chosen > 0) {
      expansion_cutoff.push_back(node->chosen);
    }
    for (const auto &p : node->children) {
      Count(p.second);
    }
  };
  Count(search->tree->root);
  std::sort(expansion_cutoff.begin(), expansion_cutoff.end(),
	    std::greater<int>());

  static constexpr int kMaxImages = 1000;
  const int cutoff = expansion_cutoff.size() > kMaxImages ?
    expansion_cutoff[kMaxImages] : 0;
  expansion_cutoff.clear();
  printf("Nodes expanded more than %d times will have images.\n",
	 cutoff);

  int images = 0;
  int node_num = 0;
  std::function<string(const Tree::Node *)> Rec =
    [search, &tmp, cutoff, &images, &node_num, &Rec](const Tree::Node *node) {
    int id = node_num++;
    string ret = StringPrintf("{i:%d", id);
    CHECK(node->location != -1);

    double score = -search->tree->heap.GetCell(node).priority;
    ret += StringPrintf(",s:%s", Rtos(score).c_str());

    if (node->chosen > 0) {
      ret += StringPrintf(",e:%d,w:%d", node->chosen, node->was_loss);
    }

    if (node->chosen > cutoff) {
      tmp->Restore(node->state);

      // UGH HACK. After restoring a state we don't have an image
      // unless we make a step. We could replay to here from the
      // parent node (accurate; slow), or be storing these in the
      // state (but they are 260kb each!)
      //
      // So the images stored are actually a single random frame
      // AFTER the one in the node.
      tmp->Exec(tmp->AnyInput());
      vector<uint8> argb256x256;
      argb256x256.resize(256 * 256 * 4);
      tmp->Visualize(nullptr, &argb256x256);

      SaveARGB(argb256x256, 256, 256, StringPrintf("tree/%d.png", id));
      images++;
      ret += ",g:1";
    }

    if (!node->children.empty()) {
      string ch;
      for (const auto &p : node->children) {
	if (!ch.empty()) ch += ",";
	// Note, discards sequence.
	ch += Rec(p.second);
      }
      ret += ",c:[";
      ret += ch;
      ret += "]";
    }
    ret += "}";
    return ret;
  };

  string json = StringPrintf(
      "/* Generated by pftwo.cc. Do not edit! */\n"
      "var treedata = %s\n;",
      Rec(search->tree->root).c_str());
  Printf("Wrote %d images. Writing to tree/tree.js\n", images);
  Util::WriteFile("tree/tree.js", json);
}
