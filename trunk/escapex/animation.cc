#include "animation.h"
#include "util.h"
#include "chars.h"
#include "font.h"
#include "dirt.h"
#include "ptrlist.h"

#include "progress.h"

// #define AN_SLOW 100
#define AN_SLOW 0

#define WALKPUSH_DIST 6
#define WALKPUSH_WAIT 12 /* 12 */

#define ANFLYING_PIXELS_YELLOW_SPHERE 12
#define ANFLYING_RATE_YELLOW_SPHERE 12
#define WAIT_BETWEEN_JIGGLE 15
#define WAIT_BETWEEN_WIRE 15

#define LASER_TIME 30
#define LASER_COUNT 24

#define DEATHLASER_COLORS /* high */ 255, 255, 255, /* higho */ 255, 0, 0, \
                          /* low  */ 255, 150, 0,   /* lowo  */ 255, 255, 0

#define TRANSPONDERBEAM_COUNT 6
#define TRANSPONDERBEAM_COLORS \
                          /* high */ 255, 255, 255, /* higho */ 100, 0, 255, \
                          /* low  */ 150, 150, 0,   /* lowo  */ 25, 0, 200

#define TILESIZE(d) (((d)==DIR_LEFT||(d)==DIR_RIGHT)?TILEW:TILEH)
#define LR(d) ((d)==DIR_LEFT || (d)==DIR_RIGHT)
#define UD(d) ((d)==DIR_UP || (d)==DIR_DOWN)

#define NUM_FLIPFRAMES 5
#define FLIP_PIXELS_OVERLAP 4
#define FLIP_SPEED 16

#define pic_flips_out(t, f) pic_flips_out_data[((t) * NUM_FLIPFRAMES) + (f)]
#define pic_flips_in(t, f)  pic_flips_in_data [((t) * NUM_FLIPFRAMES) + (f)]


/* generated by packpng */
#include "animation_decs.h"

SDL_Surface **Animation::pic_flips_out_data;
SDL_Surface **Animation::pic_flips_in_data;
AFrame      **Animation::frame_flips_out;
AFrame      **Animation::frame_flips_in;

/* filled in during init */
/* XXX we're never really going to make different directions
   for these bots, right? Fix it */
SDL_Surface **Animation::pic_guy_up;
SDL_Surface **Animation::pic_guy_down;
SDL_Surface **Animation::pic_guy_left;
SDL_Surface **Animation::pic_guy_right;

SDL_Surface **Animation::pic_deadrobot;

SDL_Surface **Animation::pic_dalek_up;
SDL_Surface **Animation::pic_dalek_down;
SDL_Surface **Animation::pic_dalek_left;
SDL_Surface **Animation::pic_dalek_right;

SDL_Surface **Animation::pic_hugbot_up;
SDL_Surface **Animation::pic_hugbot_down;
SDL_Surface **Animation::pic_hugbot_left;
SDL_Surface **Animation::pic_hugbot_right;


SDL_Surface **Animation::pic_dalek_asleep_up;
SDL_Surface **Animation::pic_dalek_asleep_down;
SDL_Surface **Animation::pic_dalek_asleep_left;
SDL_Surface **Animation::pic_dalek_asleep_right;

SDL_Surface **Animation::pic_hugbot_asleep_up;
SDL_Surface **Animation::pic_hugbot_asleep_down;
SDL_Surface **Animation::pic_hugbot_asleep_left;
SDL_Surface **Animation::pic_hugbot_asleep_right;

SDL_Surface **Animation::pic_bomb_still;
/* for 0..LEVEL_BOMB_MAX_TIMER */
SDL_Surface *** Animation::pic_bomb_lit;

bool Animation::ainit_fast() {
  /* also generated by packpng */
# include "animation_load.h"

  /* some of the animation frames are used for drawing the level too,
     so are needed at various sizes */

  pic_guy_up = (SDL_Surface**)malloc(DRAW_NSIZES * sizeof(SDL_Surface *));
  pic_guy_down = (SDL_Surface**)malloc(DRAW_NSIZES * sizeof(SDL_Surface *));
  pic_guy_left = (SDL_Surface**)malloc(DRAW_NSIZES * sizeof(SDL_Surface *));
  pic_guy_right = (SDL_Surface**)malloc(DRAW_NSIZES * sizeof(SDL_Surface *));

  pic_guy_up[0] = walk_backward_0;
  pic_guy_down[0] = walk_forward_0;
  pic_guy_left[0] = walk_left_0;
  pic_guy_right[0] = walk_right_0;

  if (!sdlutil::make_mipmaps(pic_guy_up, DRAW_NSIZES)) return 0;
  if (!sdlutil::make_mipmaps(pic_guy_down, DRAW_NSIZES)) return 0;
  if (!sdlutil::make_mipmaps(pic_guy_left, DRAW_NSIZES)) return 0;
  if (!sdlutil::make_mipmaps(pic_guy_right, DRAW_NSIZES)) return 0;

  /* dead */
  pic_deadrobot = (SDL_Surface**)malloc(DRAW_NSIZES * sizeof(SDL_Surface *));
  pic_deadrobot[0] = deadrobot;
  if (!sdlutil::make_mipmaps(pic_deadrobot, DRAW_NSIZES)) return 0;

  /* bomb */
  pic_bomb_still = (SDL_Surface**)malloc(DRAW_NSIZES * sizeof(SDL_Surface *));
  pic_bomb_still[0] = bomb_still;
  if (!sdlutil::make_mipmaps(pic_bomb_still, DRAW_NSIZES)) return 0;

  pic_bomb_lit = (SDL_Surface***)malloc((LEVEL_BOMB_MAX_TIMER+1) *
					sizeof (SDL_Surface **));

  {
    for (int i = 0; i <= LEVEL_BOMB_MAX_TIMER; i++) {
      pic_bomb_lit[i] = (SDL_Surface**)malloc(DRAW_NSIZES * 
					      sizeof(SDL_Surface *));

      /* going to draw on these, so duplicate */
      switch (i) {
      default: pic_bomb_lit[i][0] = sdlutil::duplicate(bomb_lit_3); break;
      case 2: pic_bomb_lit[i][0] = sdlutil::duplicate(bomb_lit_2); break;
      case 1: pic_bomb_lit[i][0] = sdlutil::duplicate(bomb_lit_1); break;
      case 0: pic_bomb_lit[i][0] = sdlutil::duplicate(bomb_lit_0); break;
      }

      /* draw timer on it */
      {
	string ss = RED + itos(i);
	fon->drawto(pic_bomb_lit[i][0], (TILEW - fon->sizex(ss))>>1,
		    ((TILEH + BOMB_OVERLAPY) - fon->height)>>1,
		    ss);
      }


      if (!sdlutil::make_mipmaps(pic_bomb_lit[i], DRAW_NSIZES)) return 0;

    }
  }

  /* dalek */
  pic_dalek_down = (SDL_Surface**)malloc(DRAW_NSIZES * sizeof(SDL_Surface *));
  pic_dalek_up = pic_dalek_down;
  pic_dalek_left = pic_dalek_down;
  pic_dalek_right = pic_dalek_down;

  pic_dalek_down[0] = dalek_forward_0;
  if (!sdlutil::make_mipmaps(pic_dalek_down, DRAW_NSIZES)) return 0;

  /* hugbot */
  pic_hugbot_down = (SDL_Surface**)malloc(DRAW_NSIZES * sizeof(SDL_Surface *));
  pic_hugbot_up = pic_hugbot_down;
  pic_hugbot_left = pic_hugbot_down;
  pic_hugbot_right = pic_hugbot_down;

  pic_hugbot_down[0] = hugbot_forward_0;
  if (!sdlutil::make_mipmaps(pic_hugbot_down, DRAW_NSIZES)) return 0;


  /* sleeping hugbot */
  pic_hugbot_asleep_down = (SDL_Surface**)
    malloc(DRAW_NSIZES * sizeof(SDL_Surface *));
  pic_hugbot_asleep_up = pic_hugbot_asleep_down;
  pic_hugbot_asleep_left = pic_hugbot_asleep_down;
  pic_hugbot_asleep_right = pic_hugbot_asleep_down;

  pic_hugbot_asleep_down[0] = hugbot_asleep;
  if (!sdlutil::make_mipmaps(pic_hugbot_asleep_down, DRAW_NSIZES)) return 0;

  /* sleeping dalek */
  pic_dalek_asleep_down = (SDL_Surface**)
    malloc(DRAW_NSIZES * sizeof(SDL_Surface *));
  pic_dalek_asleep_up = pic_dalek_asleep_down;
  pic_dalek_asleep_left = pic_dalek_asleep_down;
  pic_dalek_asleep_right = pic_dalek_asleep_down;

  pic_dalek_asleep_down[0] = dalek_asleep;
  if (!sdlutil::make_mipmaps(pic_dalek_asleep_down, DRAW_NSIZES)) return 0;


  return true;
}

bool Animation::ainit() {
  return ainit_fast() && init_flips();
}


/* some pre-built animations */

/* XXX move to another file! */

#define JIGGLEANIM(c)                               \
static AFrame frames_ ## c ## p_jiggle_ud[] =       \
  { {&Animation:: c ## phere_slide_ud, 1, -1, 0},   \
    {&Animation:: c ## phere_slide_ud2, 2, -2, 25}, \
    {&Animation:: c ## phere_slide_ud, 1, -1, 25},  \
    {0, 0, 0, 25} };                                \
                                                    \
static AFrame frames_ ## c ## p_jiggle_lr[] =       \
  { {&Animation:: c ## phere_slide_lr, -1, 1, 0},   \
    {&Animation:: c ## phere_slide_lr2, -2, 2, 25}, \
    {&Animation:: c ## phere_slide_lr, -1, 1, 25},  \
    {0, 0, 0, 25} };

JIGGLEANIM(bs);
JIGGLEANIM(gs);
JIGGLEANIM(rs);
JIGGLEANIM(s);

static AFrame frames_break[] =
  { {&Animation::break0, -5, -5, 0},
    {&Animation::break1, -5, -5, 30},
    {&Animation::break2, -5, -5, 30},
    {0, 0, 0, 30} };

static AFrame frames_zap[] =
  { {&Animation::zap0, -11, -9, 0},
    {&Animation::zap1, -11, -9, 35},
    {&Animation::zap0, -11, -9, 35},
    {&Animation::zap2, -11, -9, 35},
    {&Animation::zap3, -11, -9, 35},
    {&Animation::zap4, -11, -9, 35},
    {0, 0, 0, 35} };

#define SPHERESMUSHFRAMES(c)                          \
static AFrame frames_ ## c ## phere_smush_l[] =       \
  { {&Animation:: c ## phere_slide_ud, 0, -1, 0},     \
    {&Animation:: c ## phere_slide_ud2, 0, -2, 35},   \
    {&Animation:: c ## phere_slide_ud, 0, -1, 35},    \
    {0, 0, 0, 35} };                                  \
                                                      \
static AFrame frames_ ## c ## phere_smush_u[] =       \
  { {&Animation::c ## phere_slide_lr, -1, 0, 0},      \
    {&Animation::c ## phere_slide_lr2, -2, 0, 35},    \
    {&Animation::c ## phere_slide_lr, -1, 0, 35},     \
    {0, 0, 0, 35} };                                  \
                                                      \
static AFrame frames_ ## c ## phere_smush_r[] =       \
  { {&Animation:: c ## phere_slide_ud, 1, -1, 0},     \
    {&Animation:: c ## phere_slide_ud2, 2, -2, 35},   \
    {&Animation:: c ## phere_slide_ud, 1, -1, 35},    \
    {0, 0, 0, 35} };                                  \
                                                      \
static AFrame frames_ ## c ## phere_smush_d[] =       \
  { {&Animation::c ## phere_slide_lr, -1, 1, 0},      \
    {&Animation::c ## phere_slide_lr2, -2, 2, 35},    \
    {&Animation::c ## phere_slide_lr, -1, 1, 35},     \
    {0, 0, 0, 35} };


SPHERESMUSHFRAMES(rs);
SPHERESMUSHFRAMES(gs);
SPHERESMUSHFRAMES(bs);
SPHERESMUSHFRAMES(s);

#undef SPHERESMUSHFRAMES

static AFrame frames_bombsplosion[] =
  { {&Animation::bombsplosion, -48, -54, 0},
    {0, 0, 0, 240} };

static AFrame frames_error[] =
  { {&Animation::error, -8, 6, 0},
    {0, 0, 0, 200} };

static AFrame frames_yellow_smush_hitright[] =
  { {&Animation::yellow_stretch_ud, 6, -2, 0},
    {0, 0, 0, 60} };

static AFrame frames_yellow_smush_hitleft[] =
  { {&Animation::yellow_stretch_ud, 0, -2, 0},
    {0, 0, 0, 60} };

static AFrame frames_yellow_smush_hitdown[] =
  { {&Animation::yellow_stretch_lr, -3, 6, 0},
    {0, 0, 0, 60} };

static AFrame frames_yellow_smush_hitup[] =
  { {&Animation::yellow_stretch_lr, -3, 0, 0},
    {0, 0, 0, 60} };

/* could be better if it looked like it was being
   pushed into the hole, rather than falling straight
   down (one for each angle; shorten push anim) */
static AFrame frames_grey_drop[] =
  { {&Animation::greyshrink0, 0, 0, 0},
    {&Animation::greyshrink1, 0, 0, 20},
    {&Animation::greyshrink2, 0, 0, 20},
    {&Animation::greyshrink3, 0, 0, 20},
    {0, 0, 0, 35},
  };

static AFrame frames_smokepuff[] =
  { {&Animation::nothing, 0, 0, 0},
    {&Animation::smokepuff0, -16, -16, 160},
    {&Animation::smokepuff1, -16, -16, 65},
    {&Animation::smokepuff2, -16, -16, 65},
    {&Animation::smokepuff3, -16, -16, 65},
    {0, 0, 0, 65},
  };

static AFrame frames_shrinkhole[] =
  { {&Animation::shrinking_hole0, 0, 0, 0},
    {&Animation::shrinking_hole1, 0, 0, 40},
    {&Animation::shrinking_hole2, 0, 0, 40},
    {&Animation::shrinking_hole3, 0, 0, 40},
    {&Animation::shrinking_hole4, 0, 0, 40},
    {0, 0, 0, 40} };

static AFrame frames_slider_rotates[] =
  { {&Animation::slider_rotating, 0, 0, 0},
    {0, 0, 0, 65} };

static AFrame frames_electric_off[] =
  { {&Animation::elecoff0, 0, 0, 0},
    {&Animation::elecoff1, 0, 0, 40},
    {&Animation::elecoff2, 0, 0, 40},
    {&Animation::elecoff3, 0, 0, 40},
    {&Animation::elecoff4, 0, 0, 60},
    {0, 0, 0, 60} };

static AFrame frames_ongoesoff[] =
  { {&Animation::ongoesoff0, 0, 0, 0},
    {&Animation::ongoesoff1, 0, 0, 40},
    {0, 0, 0, 60} };

static AFrame frames_onezero_fade[] =
  { {&Animation::onezero_fade0, 0, 0, 0},
    {&Animation::onezero_fade1, 0, 0, 40},
    {&Animation::onezero_fade0, 0, 0, 40},
    {0, 0, 0, 40} };

static AFrame frames_trap1_falls[] = 
  { {&Animation::trap1_falls0, 0, 0, 0},
    {&Animation::trap1_falls1, 0, 0, 40},
    {&Animation::trap1_falls2, 0, 0, 40},
    {&Animation::trap1_falls3, 0, 0, 40},
    {0, 0, 0, 40} };

/* XXX could be improved */
static AFrame frames_trap2_falls[] = 
  { {&Animation::trap2_falls0, 0, 0, 0},
    {&Animation::trap2_falls1, 0, 0, 80},
    {0, 0, 0, 80} };

static AFrame frames_green_pushright[] =
  { {&Animation::green_pushright0, 2, 0, 0},
    {&Animation::green_pushright1, 4, 0, 60},
    {&Animation::green_pushright2, 0, 0, 50},
    {&Animation::green_pushright3, -4, 0, 40},
    {&Animation::green_pushright4, -2, 0, 30},
    {0, 0, 0, 20} };

static AFrame frames_green_pushleft[] =
  { {&Animation::green_pushleft0, -2, 0, 0},
    {&Animation::green_pushleft1, -4, 0, 60},
    {&Animation::green_pushleft2, 0, 0, 50},
    {&Animation::green_pushleft3, 4, 0, 40},
    {&Animation::green_pushleft4, 2, 0, 30},
    {0, 0, 0, 20}
  };

static AFrame frames_green_pushdown[] =
  { {&Animation::green_pushdown0, 0, 2, 0},
    {&Animation::green_pushdown1, 0, 4, 60},
    {&Animation::green_pushdown2, 0, 0, 50},
    {&Animation::green_pushdown3, 0, -4, 40},
    {&Animation::green_pushdown4, 0, -2, 30},
    {0, 0, 0, 20}
  };

static AFrame frames_green_pushup[] =
  { {&Animation::green_pushup0, 0, -2, 0},
    {&Animation::green_pushup1, 0, -4, 60},
    {&Animation::green_pushup2, 0, 0, 50},
    {&Animation::green_pushup3, 0, 4, 40},
    {&Animation::green_pushup4, 0, 2, 30},
    {0, 0, 0, 20}
  };

/* could use macro */
static AFrame frames_bliteup[] =
  { {&Animation::blue_lights0, -8, -8, 0},
    {&Animation::blue_lights1, -8, -8, 40},
    {&Animation::blue_lights2, -8, -8, 40},
    {&Animation::blue_lights3, -8, -8, 40},
    {&Animation::blue_lights4, -8, -8, 40},
    {&Animation::blue_lights5, -8, -8, 40},
    {0, 0, 0, 40} };

static AFrame frames_rliteup[] =
  { {&Animation::red_lights0, -8, -8, 0},
    {&Animation::red_lights1, -8, -8, 40},
    {&Animation::red_lights2, -8, -8, 40},
    {&Animation::red_lights3, -8, -8, 40},
    {&Animation::red_lights4, -8, -8, 40},
    {&Animation::red_lights5, -8, -8, 40},
    {0, 0, 0, 40} };

static AFrame frames_gliteup[] =
  { {&Animation::green_lights0, -8, -8, 0},
    {&Animation::green_lights1, -8, -8, 40},
    {&Animation::green_lights2, -8, -8, 40},
    {&Animation::green_lights3, -8, -8, 40},
    {&Animation::green_lights4, -8, -8, 40},
    {&Animation::green_lights5, -8, -8, 40},
    {0, 0, 0, 40} };

static AFrame frames_remotelite[] =
  { {&Animation::remote_lite0, 0, 0, 0},
    {&Animation::remote_lite1, 0, 0, 40},
    {&Animation::remote_lite2, 0, 0, 40},
    {&Animation::remote_lite3, 0, 0, 40},
    {&Animation::remote_lite2, 0, 0, 40},
    {&Animation::remote_lite3, 0, 0, 40},
    {&Animation::remote_lite6, 0, 0, 40},
    {0, 0, 0, 40} };

/* XXX make different send and recv anims */
static AFrame frames_transponder[] =
  { {&Animation::transponder_lite1, 0, 0, 0},
    {&Animation::transponder_lite2, 0, 0, 40},
    {&Animation::transponder_lite3, 0, 0, 40},
    {&Animation::transponder_lite4, 0, 0, 40},
    {&Animation::transponder_lite5, 0, 0, 40},
    {0, 0, 0, 40} };

static AFrame frames_bluefloor_goup[] =
  { {&Animation::bluefloor1, 0, 0, 0},
    {&Animation::bluefloor0, 0, 0, 60},
    {0, 0, 0, 60} };

static AFrame frames_bluefloor_godown[] =
  { {&Animation::bluefloor0, 0, 0, 0},
    {&Animation::bluefloor1, 0, 0, 60},
    {0, 0, 0, 60} };

static AFrame frames_greenfloor_goup[] =
  { {&Animation::greenfloor1, 0, 0, 0},
    {&Animation::greenfloor0, 0, 0, 60},
    {0, 0, 0, 60} };

static AFrame frames_greenfloor_godown[] =
  { {&Animation::greenfloor0, 0, 0, 0},
    {&Animation::greenfloor1, 0, 0, 60},
    {0, 0, 0, 60} };


static AFrame frames_redfloor_goup[] =
  { {&Animation::redfloor1, 0, 0, 0},
    {&Animation::redfloor0, 0, 0, 60},
    {0, 0, 0, 60} };

static AFrame frames_redfloor_godown[] =
  { {&Animation::redfloor0, 0, 0, 0},
    {&Animation::redfloor1, 0, 0, 60},
    {0, 0, 0, 60} };

static AFrame frames_opendoor[] =
  { {&Animation::door_opens0, 0, 0, 0},
    {&Animation::door_opens1, 0, 0, 60},
    {&Animation::door_opens2, 0, 0, 60},
    {0, 0, 0, 60} };

#define JUICEWIRE(dd) \
  static AFrame frames_juice_ ## dd[] = \
  { {&Animation::juicedwire_ ## dd, 0, 0, 0}, \
    {&Animation::juicedwire_ ## dd ## 1, 0, 0, 20}, \
    {0, 0, 0, 20} }

JUICEWIRE(ns);
JUICEWIRE(ne);
JUICEWIRE(nw);
JUICEWIRE(sw);
JUICEWIRE(se);
JUICEWIRE(we);
JUICEWIRE(nswe_ud);
JUICEWIRE(nswe_lr);

#undef JUICEWIRE

/* smoothest, faster */
static AFrame frames_walkforward[] =
  { {&Animation::walk_forward_a,  0, 4, 0},
    {&Animation::walk_forward_a2, 0, 8, 20},
    {&Animation::walk_forward_a,  0, 12, 40},
    {&Animation::walk_forward_0,  0, 16, 20},
    {&Animation::walk_forward_b,  0, 20, 20},
    {&Animation::walk_forward_b2, 0, 24, 20},
    {&Animation::walk_forward_b,  0, 28, 40},
    {&Animation::walk_forward_0,  0, 32, 20},
    {0, 0, 0, 0} };

static AFrame frames_walkbackward[] =
  { {&Animation::walk_backward_a,  0, -4, 0},
    {&Animation::walk_backward_a2, 0, -8, 20},
    {&Animation::walk_backward_a,  0, -12, 40},
    {&Animation::walk_backward_0,  0, -16, 20},
    {&Animation::walk_backward_b,  0, -20, 20},
    {&Animation::walk_backward_b2, 0, -24, 20},
    {&Animation::walk_backward_b,  0, -28, 40},
    {&Animation::walk_backward_0,  0, -32, 20},
    {0, 0, 0, 0} };

static AFrame frames_walkright[] =
  { {&Animation::walk_right_a,  4,  0,  0},
    {&Animation::walk_right_a2, 8,  0,  20},
    {&Animation::walk_right_a,  12, 0,  40},
    {&Animation::walk_right_0,  16, 0,  20},
    {&Animation::walk_right_b,  20, 0,  20},
    {&Animation::walk_right_b2, 24, 0,  20},
    {&Animation::walk_right_b,  28, 0,  40},
    {&Animation::walk_right_0,  32, 0,  20},
    {0, 0, 0, 0} };

static AFrame frames_walkleft[] =
  { {&Animation::walk_left_a,  -4,  0,  0},
    {&Animation::walk_left_a2, -8,  0,  20},
    {&Animation::walk_left_a,  -12, 0,  40},
    {&Animation::walk_left_0,  -16, 0,  20},
    {&Animation::walk_left_b,  -20, 0,  20},
    {&Animation::walk_left_b2, -24, 0,  20},
    {&Animation::walk_left_b,  -28, 0,  40},
    {&Animation::walk_left_0,  -32, 0,  20},
    {0, 0, 0, 0} };

/* daleks */
#define dalek_backward_0 dalek_forward_0
#define dalek_backward_1 dalek_forward_1
#define dalek_left_0 dalek_forward_0
#define dalek_left_1 dalek_forward_1
#define dalek_right_0 dalek_forward_0
#define dalek_right_1 dalek_forward_1

static AFrame frames_dalekforward[] =
  { {&Animation::dalek_forward_1,  0, 4, 0},
    {&Animation::dalek_forward_1,  0, 8, 20},
    {&Animation::dalek_forward_1,  0, 12, 40},
    {&Animation::dalek_forward_0,  0, 16, 20},
    {&Animation::dalek_forward_0,  0, 20, 20},
    {&Animation::dalek_forward_0,  0, 24, 20},
    {&Animation::dalek_forward_1,  0, 28, 40},
    {&Animation::dalek_forward_1,  0, 32, 20},
    {0, 0, 0, 0} };

static AFrame frames_dalekbackward[] =
  { {&Animation::dalek_backward_1,  0, -4, 0},
    {&Animation::dalek_backward_1,  0, -8, 20},
    {&Animation::dalek_backward_1,  0, -12, 40},
    {&Animation::dalek_backward_0,  0, -16, 20},
    {&Animation::dalek_backward_0,  0, -20, 20},
    {&Animation::dalek_backward_0,  0, -24, 20},
    {&Animation::dalek_backward_1,  0, -28, 40},
    {&Animation::dalek_backward_1,  0, -32, 20},
    {0, 0, 0, 0} };

static AFrame frames_dalekright[] =
  { {&Animation::dalek_right_1,  4,  0,  0},
    {&Animation::dalek_right_1,  8,  0,  20},
    {&Animation::dalek_right_1,  12, 0,  40},
    {&Animation::dalek_right_0,  16, 0,  20},
    {&Animation::dalek_right_0,  20, 0,  20},
    {&Animation::dalek_right_0,  24, 0,  20},
    {&Animation::dalek_right_1,  28, 0,  40},
    {&Animation::dalek_right_1,  32, 0,  20},
    {0, 0, 0, 0} };

static AFrame frames_dalekleft[] =
  { {&Animation::dalek_left_1,  -4,  0,  0},
    {&Animation::dalek_left_1,  -8,  0,  20},
    {&Animation::dalek_left_1,  -12, 0,  40},
    {&Animation::dalek_left_0,  -16, 0,  20},
    {&Animation::dalek_left_0,  -20, 0,  20},
    {&Animation::dalek_left_0,  -24, 0,  20},
    {&Animation::dalek_left_1,  -28, 0,  40},
    {&Animation::dalek_left_1,  -32, 0,  20},
    {0, 0, 0, 0} };

/* end daleks */

/* hugbots */
#define hugbot_backward_0 hugbot_forward_0
#define hugbot_backward_1 hugbot_forward_1
#define hugbot_left_0 hugbot_forward_0
#define hugbot_left_1 hugbot_forward_1
#define hugbot_right_0 hugbot_forward_0
#define hugbot_right_1 hugbot_forward_1

static AFrame frames_hugbotforward[] =
  { {&Animation::hugbot_forward_1,  0, 4, 0},
    {&Animation::hugbot_forward_1,  0, 8, 20},
    {&Animation::hugbot_forward_1,  0, 12, 40},
    {&Animation::hugbot_forward_0,  0, 16, 20},
    {&Animation::hugbot_forward_0,  0, 20, 20},
    {&Animation::hugbot_forward_0,  0, 24, 20},
    {&Animation::hugbot_forward_1,  0, 28, 40},
    {&Animation::hugbot_forward_1,  0, 32, 20},
    {0, 0, 0, 0} };

static AFrame frames_hugbotbackward[] =
  { {&Animation::hugbot_backward_1,  0, -4, 0},
    {&Animation::hugbot_backward_1,  0, -8, 20},
    {&Animation::hugbot_backward_1,  0, -12, 40},
    {&Animation::hugbot_backward_0,  0, -16, 20},
    {&Animation::hugbot_backward_0,  0, -20, 20},
    {&Animation::hugbot_backward_0,  0, -24, 20},
    {&Animation::hugbot_backward_1,  0, -28, 40},
    {&Animation::hugbot_backward_1,  0, -32, 20},
    {0, 0, 0, 0} };

static AFrame frames_hugbotright[] =
  { {&Animation::hugbot_right_1,  4,  0,  0},
    {&Animation::hugbot_right_1,  8,  0,  20},
    {&Animation::hugbot_right_1,  12, 0,  40},
    {&Animation::hugbot_right_0,  16, 0,  20},
    {&Animation::hugbot_right_0,  20, 0,  20},
    {&Animation::hugbot_right_0,  24, 0,  20},
    {&Animation::hugbot_right_1,  28, 0,  40},
    {&Animation::hugbot_right_1,  32, 0,  20},
    {0, 0, 0, 0} };

static AFrame frames_hugbotleft[] =
  { {&Animation::hugbot_left_1,  -4,  0,  0},
    {&Animation::hugbot_left_1,  -8,  0,  20},
    {&Animation::hugbot_left_1,  -12, 0,  40},
    {&Animation::hugbot_left_0,  -16, 0,  20},
    {&Animation::hugbot_left_0,  -20, 0,  20},
    {&Animation::hugbot_left_0,  -24, 0,  20},
    {&Animation::hugbot_left_1,  -28, 0,  40},
    {&Animation::hugbot_left_1,  -32, 0,  20},
    {0, 0, 0, 0} };

/* end hugbots */

static AFrame frames_lasered[] =
  { {&Animation::lasered0, 0, 0, 0},
    {&Animation::lasered1, 0, 0, 90},
    {&Animation::lasered0, 0, 0, 90},
    {&Animation::lasered2, 0, 0, 90},
    {&Animation::lasered0, 0, 0, 90},
    {&Animation::lasered1, 0, 0, 90},
    {&Animation::lasered0, 0, 0, 90},
    {&Animation::lasered2, 0, 0, 90},
    {0, 0, 0, 90} };

/* the following bots don't animate when being
   pushed; consider treating them in a different way */

#define STATIC_BOT_FRAMES(name, frame) \
   static AFrame frames_ ## name ## forward[] = \
  { {&Animation::frame,  0, 4, 0},              \
    {&Animation::frame,  0, 8, 20},             \
    {&Animation::frame,  0, 12, 40},            \
    {&Animation::frame,  0, 16, 20},            \
    {&Animation::frame,  0, 20, 20},            \
    {&Animation::frame,  0, 24, 20},            \
    {&Animation::frame,  0, 28, 40},            \
    {&Animation::frame,  0, 32, 20},            \
    {0, 0, 0, 0} };                             \
                                                \
static AFrame frames_ ## name ## backward[] =   \
  { {&Animation::frame,  0, -4, 0},             \
    {&Animation::frame,  0, -8, 20},            \
    {&Animation::frame,  0, -12, 40},           \
    {&Animation::frame,  0, -16, 20},           \
    {&Animation::frame,  0, -20, 20},           \
    {&Animation::frame,  0, -24, 20},           \
    {&Animation::frame,  0, -28, 40},           \
    {&Animation::frame,  0, -32, 20},           \
    {0, 0, 0, 0} };                             \
                                                \
static AFrame frames_ ## name ## right[] =      \
  { {&Animation::frame,  4,  0,  0},            \
    {&Animation::frame,  8,  0,  20},           \
    {&Animation::frame,  12, 0,  40},           \
    {&Animation::frame,  16, 0,  20},           \
    {&Animation::frame,  20, 0,  20},           \
    {&Animation::frame,  24, 0,  20},           \
    {&Animation::frame,  28, 0,  40},           \
    {&Animation::frame,  32, 0,  20},           \
    {0, 0, 0, 0} };                             \
                                                \
static AFrame frames_ ## name ## left[] =       \
  { {&Animation::frame,  -4,  0,  0},           \
    {&Animation::frame,  -8,  0,  20},          \
    {&Animation::frame,  -12, 0,  40},          \
    {&Animation::frame,  -16, 0,  20},          \
    {&Animation::frame,  -20, 0,  20},          \
    {&Animation::frame,  -24, 0,  20},          \
    {&Animation::frame,  -28, 0,  40},          \
    {&Animation::frame,  -32, 0,  20},          \
    {0, 0, 0, 0} }

STATIC_BOT_FRAMES(deadrobot, deadrobot);
STATIC_BOT_FRAMES(hugbot_asleep, hugbot_asleep);
STATIC_BOT_FRAMES(dalek_asleep, dalek_asleep);

static AFrame frames_attention[] =
  { {&Animation::attention, 24, 0, 0},
    {0, 0, 0, 460} };

static AFrame frames_doorwake[] =
  { {&Animation::doorwake_1, 0, 0, 0},
    {&Animation::doorwake_2, 0, 0, 60},
    {&Animation::doorwake_4, 0, 0, 60},
    {&Animation::doorwake_3, 0, 0, 140},
    {&Animation::doorwake_4, 0, 0, 140},
    {&Animation::doorwake_5, 0, 0, 60},
    {&Animation::doorwake_4, 0, 0, 140},
    {&Animation::doorwake_3, 0, 0, 60},
    {&Animation::doorwake_6, 0, 0, 140},
    {&Animation::doorwake_7, 0, 0, 60},
    {0, 0, 0, 60} };

static AFrame frames_hf_evaporate[] =
  { {&Animation::hf_evaporate0, -6, -6, 0},
    {&Animation::hf_evaporate1, -6, -6, 60},
    {0, 0, 0, 60} };

static AFrame frames_guy_teleport_out[] =
  { {&Animation::guy_teleport0, 1, -28, 0},
    {&Animation::guy_teleport1, 1, -29, 20},
    {&Animation::guy_teleport2, 1, -31, 20},
    {&Animation::guy_teleport3, 1, -32, 20},
    {&Animation::guy_teleport4, 1, -33, 20},
    {&Animation::guy_teleport5, 1, -34, 20},
    {&Animation::guy_teleport6, 1, -35, 20},
    {0, 0, 0, 20} };

static AFrame frames_guy_teleport_in[] =
  { {&Animation::guy_teleport6, 1, -28, 0},
    {&Animation::guy_teleport5, 1, -28, 20},
    {&Animation::guy_teleport4, 1, -28, 20},
    {&Animation::guy_teleport3, 1, -28, 20},
    {&Animation::guy_teleport2, 1, -28, 20},
    {&Animation::guy_teleport1, 1, -28, 20},
    {&Animation::guy_teleport0, 1, -28, 20},
    {0, 0, 0, 20} };

static AFrame frames_dalek_teleport_out[] =
  { {&Animation::dalek_teleport0, 1, -28, 0},
    {&Animation::dalek_teleport1, 1, -29, 20},
    {&Animation::dalek_teleport2, 1, -31, 20},
    {&Animation::dalek_teleport3, 1, -32, 20},
    {&Animation::dalek_teleport4, 1, -33, 20},
    {0, 0, 0, 20} };

static AFrame frames_dalek_teleport_in[] =
  { {&Animation::dalek_teleport4, 1, -28, 20},
    {&Animation::dalek_teleport3, 1, -28, 20},
    {&Animation::dalek_teleport2, 1, -28, 20},
    {&Animation::dalek_teleport1, 1, -28, 20},
    {&Animation::dalek_teleport0, 1, -28, 20},
    {0, 0, 0, 20} };

typedef PtrList<Animation> alist;

static inline SDL_Surface *FACING_FRAME(dir d, bot entt, int data) {
  switch (entt) {
  default:
    if (Level::isbomb(entt)) {
      if (data < 0) return Animation::pic_bomb_still[0];
      else return Animation::pic_bomb_lit[data][0];
    } 
    /* else FALLTHROUGH */
  case B_DELETED:
  case B_BOMB_X:
    return Animation::error;

  case B_PLAYER:
    switch (d) {
    default:
    case DIR_UP: return Animation::pic_guy_up[0]; 
    case DIR_DOWN: return Animation::pic_guy_down[0]; 
    case DIR_LEFT: return Animation::pic_guy_left[0];
    case DIR_RIGHT: return Animation::pic_guy_right[0];
    }
  case B_HUGBOT: return Animation::pic_hugbot_down[0];
  case B_DALEK: return Animation::pic_dalek_down[0];
  case B_BROKEN: return Animation::pic_deadrobot[0];
  case B_HUGBOT_ASLEEP: return Animation::pic_hugbot_asleep_down[0];
  case B_DALEK_ASLEEP: return Animation::pic_dalek_asleep_down[0];
  }
}

static inline int OVERLAP(bot entt) {
  switch (entt) {
  case B_BROKEN: return BROKEN_OVERLAPY;
  case B_HUGBOT_ASLEEP:
  case B_HUGBOT: return HUGBOT_OVERLAPY;
  case B_DALEK_ASLEEP:
  case B_DALEK: return DALEK_OVERLAPY;
  case B_PLAYER: return GUY_OVERLAPY;

  default:
    if (Level::isbomb(entt)) return BOMB_OVERLAPY;
    else return BROKEN_OVERLAPY; /* ??? */
  }
}

/* XXX: In switches where the default should not occur, show error
   frames instead of silently ignoring the animation. A fairly serious
   bug persisted for many years on every bomb explosion because we
   ignored a nonsensical animation. */
void Animation::start(drawing &dr, 
		      PtrList<Animation> *&anims,
		      PtrList<Animation> *&sprites,
		      aevent *ae) {
  
  switch (ae->t) {
  case tag_winner:
    // XXX implement this
    break;

  case tag_teleportout: {
    teleportout_t *at = &(ae->u.teleportout);

    AFrame *frames_ent;
    switch (at->entt) {
    case B_PLAYER:
      frames_ent = frames_guy_teleport_out;
      break;
    case B_DALEK:
      frames_ent = frames_dalek_teleport_out;
      break;
    default:
      frames_ent = frames_error;
      break;
    }

    int xx, yy;
    if (dr.onscreen(at->x, at->y, xx, yy)) {
      // Animation *a = new AnPlaceTile(T_TRANSPORT, xx, yy);
      Animation *a = /* a->next = */ new AnInPlace(xx, yy, 1, frames_ent);
      alist::push(anims, a);
    }
    break;
  }

  case tag_teleportin: {
    teleportin_t *at = &(ae->u.teleportin);

    AFrame *frames_ent;
    SDL_Surface *finale;
    int overlapy;
    switch (at->entt) {
    case B_PLAYER:
      frames_ent = frames_guy_teleport_in;
      finale = Animation::pic_guy_down[0];
      overlapy = GUY_OVERLAPY;
      break;
    case B_DALEK:
      frames_ent = frames_dalek_teleport_in;
      finale = Animation::pic_dalek_down[0];
      overlapy = DALEK_OVERLAPY;
      break;
    default:
      frames_ent = frames_error;
      finale = Animation::error;
      overlapy = 0;
      break;
    }

    int xx, yy;
    if (dr.onscreen(at->x, at->y, xx, yy)) {
      AnFinale *ag = new AnFinale(finale, xx, yy - overlapy);
      Animation *a = new AnInPlace(xx, yy, 1, frames_ent);
      a->next = ag;
      alist::push(sprites, a);
    }
    break;
  }

  case tag_getheartframer: {
    getheartframer_t *ag = &(ae->u.getheartframer);

    int xx, yy;
    if (dr.onscreen(ag->x, ag->y, xx, yy)) {
      Animation *a = new AnPlaceTile(T_FLOOR, xx, yy);
      a->next = new AnInPlace(xx, yy, 1, frames_hf_evaporate);
      alist::push(sprites, a);
    }
    break;
  }

  case tag_wakeup: {
    wakeup_t *aw = &(ae->u.wakeup);

    int xx, yy;
    if (dr.onscreen(aw->x, aw->y, xx, yy)) {
      Animation *aa = new AnInPlace(xx, yy, 1, frames_attention);
      aa->depth = 2;
      alist::push(sprites, aa);

      /* XX bot standing? */
    }
    break;
  }

  case tag_wakeupdoor: {
    wakeupdoor_t *aw = &(ae->u.wakeupdoor);

    int xx, yy;
    if (dr.onscreen(aw->x, aw->y, xx, yy)) {
      Animation *aa = new AnInPlace(xx, yy, 1, frames_attention);
      aa->depth = 2;
      alist::push(anims, aa);

      Animation *a = new AnInPlace(xx, yy, 1, frames_doorwake);
      a->next = new AnPlaceTile(T_EXIT, xx, yy); 
      alist::push(anims, a);

    }
    break;
  }

  case tag_lasered: {
    lasered_t *al = &(ae->u.lasered);

    int xx, yy;
    if (dr.onscreen(al->x, al->y, xx, yy)) {

      /* compute ntiles so animated laser doesn't
	 go off drawing area */
      int nt = 0;
      dir dd = al->from;
      int dummy;
      for (int wx = al->x, wy = al->y; 
	  /* haven't gotten there */
	  !(wx == al->lx && wy == al->ly)
	    && /* still on screen */
	    dr.onscreen(wx, wy, dummy, dummy);
	  dr.lev->travel(wx, wy, dd, wx, wy)) {
	nt++;
      }

      if (al->from != DIR_NONE) {
	Animation *l = new AnLaser(xx, yy, al->from, 
				    nt,
				    LASER_COUNT,
				    true,
				    DEATHLASER_COLORS);
	alist::push(anims, l);
      } 

      Animation *a = new AnInPlace(xx, yy - GUY_OVERLAPY, 
				    1, frames_lasered);
      a->depth = 10; /* above everything */

      Animation *af = new AnFinale(lasered2,
				    xx, yy - GUY_OVERLAPY);
      af->depth = 10;
      a->next = af;


      Animation *az = new AnInPlace(xx, yy, 1, frames_zap);
      az->depth = 2;
      /* optional */
      alist::push(anims, az);

      alist::push(sprites, a);
    }
    break;
  }

  case tag_transponderbeam: {
    transponderbeam_t *at = &(ae->u.transponderbeam);

    int xx, yy;
    if (dr.onscreen(at->x, at->y, xx, yy)) {

      /* compute ntiles so animated beam doesn't
	 go off drawing area */
      int nt = 0;
      dir dd = at->from;
      int dummy;
      for (int wx = at->x, wy = at->y; 
	  /* haven't gotten there */
	  !(wx == at->lx && wy == at->ly)
	    && /* still on screen */
	    dr.onscreen(wx, wy, dummy, dummy);
	  dr.lev->travel(wx, wy, dd, wx, wy)) {
	nt++;
      }

      if (at->from != DIR_NONE) {
	/* XXX can't use AnLaser:
	   - needs erase */
	Animation *l = new AnLaser(xx, yy, at->from, 
				    nt, TRANSPONDERBEAM_COUNT,
				    false,
				    TRANSPONDERBEAM_COLORS);
	Animation *ar = new AnWait(at->count * (WAIT_BETWEEN_WIRE + AN_SLOW));
	ar->next = l;
	alist::push(anims, ar);
      } 
    }
    break;
  }

  case tag_opendoor: {
    opendoor_t *ao = &(ae->u.opendoor);

    int xx, yy;
    if (dr.onscreen(ao->x, ao->y, xx, yy)) {
      /* maybe also some fanfare graphics */
      Animation *ar = new AnInPlace(xx, yy, 1, frames_opendoor);
      Animation *af = new AnDraw(door_opens2, xx, yy);
      ar->next = af;
      alist::push(anims, ar);
    }
    break;
  }

  case tag_liteup: {
    liteup_t *al = &(ae->u.liteup);

    int xx, yy;

    AFrame *frames = 0;
    sound_t s = S_ERROR;
    switch (al->what) {
    default: frames = frames_error; break;
    case T_BLIGHT: frames = frames_bliteup; s = S_BLUELIGHT; break;
    case T_RLIGHT: frames = frames_rliteup; s = S_REDLIGHT; break;
    case T_GLIGHT: frames = frames_gliteup; s = S_GREENLIGHT; break;
    case T_REMOTE: frames = frames_remotelite; s = S_ERROR; /* XXX S_REMOTE */ break;
      break;
    }
    
    /* XXX offscreen sounds softer? */
    Animation *ar = new AnWait(al->delay * (WAIT_BETWEEN_WIRE + AN_SLOW));
    ar->next = new AnSound(s);
    if (dr.onscreen(al->x, al->y, xx, yy)) {
      ar->next->next = new AnInPlace(xx, yy, 1, frames);
    }

    alist::push(anims, ar);
    
    break;
  }

  case tag_litewire: {
    litewire_t *aj = &(ae->u.litewire);
    
    int xx, yy;

    if (dr.onscreen(aj->x, aj->y, xx, yy)) {
      AFrame *frames = 0;
      switch (aj->what) {
#define JUICEFRAME(DD, dd) \
          case T_ ## DD: frames = frames_juice_ ## dd; break;
      default:
	frames = frames_error; break;
	JUICEFRAME(NS, ns);
	JUICEFRAME(NW, nw);
	JUICEFRAME(NE, ne);
	JUICEFRAME(SW, sw);
	JUICEFRAME(SE, se);
	JUICEFRAME(WE, we);
      case T_TRANSPONDER:
	/* XXX differentiate send/recv */
	frames = frames_transponder; break;
      case T_NSWE:
	if (aj->dir == DIR_UP ||
	    aj->dir == DIR_DOWN) frames = frames_juice_nswe_ud;
	else frames = frames_juice_nswe_lr;
	break;
      }

      Animation *ar = new AnWait(aj->count * (WAIT_BETWEEN_WIRE + AN_SLOW));
      ar->next = new AnInPlace(xx, yy, 1, frames);

      alist::push(anims, ar);
    }
    break;
  }

  case tag_pushgreen: {
    pushgreen_t *ag = &(ae->u.pushgreen);

    int xx, yy, dx, dy, dxx, dyy;
    if (dr.onscreen(ag->srcx, ag->srcy, xx, yy) &&
	dr.lev->travel(ag->srcx, ag->srcy, ag->d, dx, dy) &&
	dr.onscreen(dx, dy, dxx, dyy)) {

      int ax = xx;
      int ay = yy;

      AFrame *frames;

      switch (ag->d) {
      default: /* impossible */
      case DIR_RIGHT:
	frames = frames_green_pushright;
	break;
      case DIR_LEFT:
	frames = frames_green_pushleft;
	ax = xx - TILEW;
	break;
      case DIR_DOWN:
	frames = frames_green_pushdown;
	break;
      case DIR_UP:
	frames = frames_green_pushup;
	ay = yy - TILEH;
	break;
      }

      AnPlaceTile *ap = new AnPlaceTile(T_FLOOR, xx, yy);
      Animation *ar = new AnInPlace(ax, ay, 1, frames);

      ap->next = ar;
      ar->next = new AnPlaceTile(T_BLUE, dxx, dyy);

      alist::push(anims, ap);
    }

    break;
  }

  case tag_bombsplosion: {
    bombsplosion_t *ab = &(ae->u.bombsplosion);

    int xx, yy;
    /* this is big, so this might not be a 
       reasonable approximation--might want to 
       use cliprect instead */
    if (dr.onscreen(ab->x, ab->y, xx, yy)) {

      /* first paint the affected tiles, then the explosion atop that */

      for (dir dd = FIRST_DIR_SELF; dd <= LAST_DIR; dd++) {
	int bx, by;
	int bbx, bby;
	if (dr.lev->travel(ab->x, ab->y, dd, bx, by)
	    && dr.onscreen(bx, by, bbx, bby)) {
	  alist::push(anims, new AnPlaceTile(dr.lev->tileat(bx, by), bbx, bby));
	}
      }

      Animation *ar = new AnInPlace(xx, yy, 1, frames_bombsplosion);
      
      alist::push(anims, ar);
    }
    break;
  }

  case tag_trap: {
    trap_t *at = &(ae->u.trap);

    int xx, yy;
    if (dr.onscreen(at->x, at->y, xx, yy)) {

      int destt;
      AFrame *frames_fall;
      switch (at->whatold) {
      case T_TRAP1:
	destt = T_HOLE;
	frames_fall = frames_trap1_falls;
	break;
      case T_TRAP2:
	destt = T_TRAP1;
	frames_fall = frames_trap2_falls;
	break;
      default:
	destt = T_FLOOR;
	frames_fall = frames_error;
	break;
      }

      /* PERF could use non-erasing (and non-alpha) blit
	 for these animations */
      AnPlaceTile *ap = new AnPlaceTile(at->whatold, xx, yy);
      Animation *ar = new AnInPlace(xx, yy, 1, frames_fall);

      ap->next = ar;
      ar->next = new AnPlaceTile(destt, xx, yy);

      alist::push(anims, ap);
    }
    break;
  }

  case tag_button: {
    button_t *ab = &(ae->u.button);

    int xx, yy;

    int destt;
    AFrame *frames_pressing;
    sound_t s = S_ERROR;
    switch (ab->whatold) {
    case T_1:
    case T_0:
      /* XXX sound!! */
      frames_pressing = frames_onezero_fade;
      destt = (ab->whatold==T_1)?T_0:T_1;
      break;
    case T_ON: 
      s = S_POWEROFF;
      destt = T_OFF;
      frames_pressing = frames_ongoesoff;
      break;
    default:
      /* XXX button */
      /* XXX show error anim in impossible cases */
      return ;
    }

    Animation *ap = new AnSound(s);
    if (dr.onscreen(ab->x, ab->y, xx, yy)) {
      /* PERF could use non-erasing (and non-alpha) blit
	 for these animations */
      ap->next = new AnPlaceTile(ab->whatold, xx, yy);
      ap->next->next = new AnInPlace(xx, yy, 1, frames_pressing);
      ap->next->next->next = new AnPlaceTile(destt, xx, yy);
    }

    alist::push(anims, ap);
    break;
  }

  case tag_toggle: {
    toggle_t *at = &(ae->u.toggle);

    int xx, yy;
    if (dr.onscreen(at->x, at->y, xx, yy)) {

      int destt;
      AFrame *frames_rotating;
      switch (at->whatold) {
	/* could maybe go other direction for one */
      case T_UD: 
	destt = T_LR;
	frames_rotating = frames_slider_rotates;
	break;
      case T_LR: 
	destt = T_UD;
	frames_rotating = frames_slider_rotates;
	break;
      case T_ELECTRIC:
	destt = T_FLOOR;
	frames_rotating = frames_electric_off;
	break;
      case T_BUP:
	destt = T_BDOWN;
	frames_rotating = frames_bluefloor_godown;
	break;
      case T_BDOWN:
	destt = T_BUP;
	frames_rotating = frames_bluefloor_goup;
	break;
      case T_GUP:
	destt = T_GDOWN;
	frames_rotating = frames_greenfloor_godown;
	break;
      case T_GDOWN:
	destt = T_GUP;
	frames_rotating = frames_greenfloor_goup;
	break;
      case T_RUP:
	destt = T_RDOWN;
	frames_rotating = frames_redfloor_godown;
	break;
      case T_RDOWN:
	destt = T_RUP;
	frames_rotating = frames_redfloor_goup;
	break;
      default:
	destt = T_FLOOR;
	frames_rotating = frames_error;
	break;
      }

      /* PERF could use non-erasing (and non-alpha) blit
	 for these animations */
      AnPlaceTile *ap = new AnPlaceTile(at->whatold, xx, yy);
      Animation *ar = new AnInPlace(xx, yy, 1, frames_rotating);

      ap->next = ar;
      ar->next = new AnPlaceTile(destt, xx, yy);

      if (at->delay) {
	Animation *aw = new AnWait(at->delay * (WAIT_BETWEEN_WIRE + AN_SLOW));
	aw->next = ap;
	alist::push(anims, aw);
      } else {
	alist::push(anims, ap);
      }
	

    }
    break;
  }

  case tag_breaks: {
    breaks_t *ab = &(ae->u.breaks);
    
    /* really easy. */
    int startx, starty;
    if (dr.onscreen(ab->x, ab->y, startx, starty)) {

      /* put floor */
      AnPlaceTile *ap = 
	new AnPlaceTile(T_FLOOR, startx, starty);

      ap->next = new AnInPlace(startx, starty, 1, frames_break);
      alist::push(anims, ap);
    }
    break;
  }

  case tag_swap: {
    swap_t *as = &(ae->u.swap);
    
    int sx, sy;
    if (dr.onscreen(as->x, as->y, sx, sy)) {
      /* queue up flip anim */
      AnPlaceTile *ap =
	new AnPlaceTile(T_BLACK, sx, sy);
      AnInPlace *aout =
	new AnInPlace(sx, sy, 1, frame_flips_out[as->was]);
      AnInPlace *ain =
	new AnInPlace(sx, sy, 1, frame_flips_in[as->now]);
      AnPlaceTile *ad =
	new AnPlaceTile(as->now, sx, sy);

      ap->next = aout;
      aout->next = ain;
      ain->next = ad;

      alist::push(anims, ap);
    }
    break;
  }

  case tag_jiggle: {
    /* do little jiggling. */
    jiggle_t *aj = &(ae->u.jiggle);

    int cx = aj->startx;
    int cy = aj->starty;

    int sx, sy;

    int waitn = 0;
    int dist = aj->num;

    while (dist-- && dr.onscreen(cx, cy, sx, sy)) {

      /* XXX this is wrong. the sphere may have been
	 the target of a panel and be gone now. 
	 
	 unfortunately the jiggle struct can't safely
	 contain an array of whats, since we use
	 the default destructor and a union. 
      */

      int what = dr.lev->tileat(cx, cy);

      AFrame *frames_jiggle;

      switch (what) {
      default: frames_jiggle = 0; break;
      case T_BSPHERE:
	if (LR(aj->d)) frames_jiggle = frames_bsp_jiggle_lr;
	else           frames_jiggle = frames_bsp_jiggle_ud;
	break;
      case T_GSPHERE:
	if (LR(aj->d)) frames_jiggle = frames_gsp_jiggle_lr;
	else           frames_jiggle = frames_gsp_jiggle_ud;
	break;
      case T_RSPHERE:
	if (LR(aj->d)) frames_jiggle = frames_rsp_jiggle_lr;
	else           frames_jiggle = frames_rsp_jiggle_ud;
	break;
      case T_SPHERE:
	if (LR(aj->d)) frames_jiggle = frames_sp_jiggle_lr;
	else           frames_jiggle = frames_sp_jiggle_ud;
	break;
      }


      if (frames_jiggle) {
	AnWait *aw = new AnWait(waitn);
	AnPlaceTile *ap = new AnPlaceTile(T_FLOOR, sx, sy);
	AnInPlace *jig = new AnInPlace(sx, sy, 1, frames_jiggle);
	AnPlaceTile *ap2 = new AnPlaceTile(what, sx, sy);

	aw->next = ap;
	ap->next = jig;
	jig->next = ap2;
	
	alist::push(anims, aw);
      }

      dr.lev->travel(cx, cy, aj->d, cx, cy);
      waitn += WAIT_BETWEEN_JIGGLE;
    }

    break;
  }

  case tag_fly: {
    fly_t *af = &(ae->u.fly);

    /* assumes the yellow brick is on the
       screen now, which should be true by
       invariant (maybe not when we add
       robots) */
    int x = af->srcx, y = af->srcy;
    int dleft = af->distance;
    int startx, starty;
    int destx, desty;
    int dist = 0;

    if (!dr.onscreen(x, y, startx, starty)) return;

    /* compute the amount that is on screen, in pixels */
    while (dleft-- &&
	  dr.lev->travel(x, y, af->d, x, y) &&
	  dr.onscreen(x, y, destx, desty)) {
      dist += TILESIZE(af->d);
    }

    int ox = 0, oy = 0;

    /* perhaps the graphic should be an argument, making this a
       general-purpose flying static image animation */
    SDL_Surface *fly;
    switch (af->d) {
    default:
    case DIR_UP:
    case DIR_DOWN:
      switch (af->what) {
      default:
      case T_GOLD: fly = Animation::yellow_slide_ud; break;
      case T_BSPHERE: fly = Animation::bsphere_slide_ud2; break;
      case T_GSPHERE: fly = Animation::gsphere_slide_ud2; break;
      case T_RSPHERE: fly = Animation::rsphere_slide_ud2; break;
      case T_SPHERE:  fly = Animation::sphere_slide_ud2; break;
      }

      ox = (TILEW - fly->w) >> 1;
      break;

    case DIR_LEFT:
    case DIR_RIGHT:
      switch (af->what) {
      default:
      case T_GOLD: fly = Animation::yellow_slide_lr; break;
      case T_BSPHERE: fly = Animation::bsphere_slide_lr2; break;
      case T_GSPHERE: fly = Animation::gsphere_slide_lr2; break;
      case T_RSPHERE: fly = Animation::rsphere_slide_lr2; break;
      case T_SPHERE:  fly = Animation::sphere_slide_lr2; break;
      }

      oy = (TILEH - fly->h) >> 1;
      break;
    }

    AnFlying *a = new AnFlying(fly,
				startx + ox, starty + oy,
				af->d,
				dist,
				ANFLYING_PIXELS_YELLOW_SPHERE,
				ANFLYING_RATE_YELLOW_SPHERE);

    AnPlaceTile *ap = 
      new AnPlaceTile(af->whatunder,
		      startx, starty);

    ap->next = a;

    /* ending animation. */

    if (af->zapped) {

      /* don't draw tile, because it is disappearing! */
      if (dleft <= 0) {
	/* XXX zapped sound */
	a->next = new AnInPlace(destx, desty, 1, frames_zap);
      }

    } else {

      AnPlaceTile *afinal =
	new AnPlaceTile(af->what, destx, desty);


      AFrame *sanim;
      switch (af->what) {
      default:
      case T_GOLD:
	switch (af->d) {
	default:
	case DIR_LEFT:  sanim = frames_yellow_smush_hitleft; break;
	case DIR_RIGHT: sanim = frames_yellow_smush_hitright; break;
	case DIR_UP:    sanim = frames_yellow_smush_hitup; break;
	case DIR_DOWN:  sanim = frames_yellow_smush_hitdown; break;
	}
	break;
#define PICKFRAMES(C, c)                                               \
      case T_ ## C ## PHERE:                                           \
	switch (af->d) {                                                \
	default:                                                       \
	case DIR_LEFT:  sanim = frames_ ## c ## phere_smush_l;  break; \
	case DIR_RIGHT: sanim = frames_ ## c ## phere_smush_r;  break; \
	case DIR_UP:    sanim = frames_ ## c ## phere_smush_u;  break; \
	case DIR_DOWN:  sanim = frames_ ## c ## phere_smush_d;  break; \
	}                                                              \
	break;
	PICKFRAMES(BS, bs);
	PICKFRAMES(GS, gs);
	PICKFRAMES(RS, rs);
	PICKFRAMES(S, s);
      }

      /* squish anim -- but only if we made it all the
	 to the end without going off the screen. */
      if (dleft <= 0) {
	/* adjust based on direction */
	a->next = new AnSound(S_CLICK);
	a->next->next = 
	  new AnInPlace(destx + ((af->d == DIR_RIGHT)?2:0),
			desty + ((af->d == DIR_DOWN)?2:0), 1, sanim);
	a->next->next->next = afinal;
      } else {
	/* and draw it in its final position */
	a->next = afinal;
      }
    }

    alist::push(anims, new AnSound(S_WHIZZ));
    alist::push(anims, ap);

    break;
  }

  case tag_push: {
    push_t *ap = &(ae->u.push);

    int dx, dy, sx, sy, sdx, sdy;
    if (dr.lev->travel(ap->srcx, ap->srcy, ap->d, dx, dy) &&
	dr.onscreen(ap->srcx, ap->srcy, sx, sy) &&
        dr.onscreen(dx, dy, sdx, sdy)) {

      AnPlaceTile *aap = 
	new AnPlaceTile(ap->under, sx, sy);

      AnFlying *af =
	new AnFlyingTile(ap->what, sx, sy, ap->d,
			 TILESIZE(ap->d), 
			 WALKPUSH_DIST,
			 WALKPUSH_WAIT);

      aap->next = af;

      if (ap->zap) {
	/* we already know dest is on screen */
	af->next = new AnInPlace(sdx, sdy, 1, frames_zap);

      } else if (ap->hole) {

	/* there are three layers. from bottom to top:
	   ash, which draws the hole shrinking
	   adrop, which draws the grey block dropping in
	   apuff, which shows a puff of smoke on top */

	/* XX better if this slides into place */
	Animation *adrop =
	  new AnInPlace(sdx, sdy, 1, frames_grey_drop);

	Animation *apuff = new AnInPlace(sdx, sdy, 1, frames_smokepuff);

	Animation *ac = new AnCombo(adrop, apuff);
	
	Animation *ash = new AnInPlace(sdx, sdy, 1, frames_shrinkhole);

	/* erase hole. */
	af->next = new AnPlaceTile(T_FLOOR, sdx, sdy);
	af->next->next = new AnCombo(ash, ac);

      } else {
	/* just draw in place */
	AnPlaceTile *ag = new AnPlaceTile(ap->what, sdx, sdy);
	af->next = ag;
      }


      alist::push(anims, aap);
    }
    break;
  }

  case tag_botexplode: {
    botexplode_t *as = &(ae->u.botexplode);
    int sx, sy;
    if (dr.onscreen(as->x, as->y, sx, sy)) {
      /* leave this bot undrawn. he's not coming back! */
      Animation *apuff = new AnInPlace(sx, sy, 1, frames_smokepuff);

      /* Replacing this with another explosion would probably
	 be nice. */
      Animation *azap = new AnInPlace(sx, sy, 1, frames_zap);
      Animation *a = new AnCombo(apuff, azap);
      a->depth = 1; /* on top of other stuff, like walking */
      alist::push(anims, a);
    }
    break;
  }

  case tag_press: {
    /* XXX draw frames for this; right now it's just STAND */
    /* XXX incorporate ent type as below */
    press_t *as = &(ae->u.press);
    int sx, sy;
    if (dr.onscreen(as->x, as->y, sx, sy)) {
      AnFinale *ag = new AnFinale(FACING_FRAME(as->d, B_PLAYER, 0),
				   sx, sy - OVERLAP(B_PLAYER));
      alist::push(sprites, ag);
    }
    break;
  }

  case tag_stand: {
    stand_t *as = &(ae->u.stand);
    int sx, sy;
    if (dr.onscreen(as->x, as->y, sx, sy)) {
      AnFinale *ag = new AnFinale(FACING_FRAME(as->d, as->entt, as->data), 
				   sx, sy - OVERLAP(as->entt));
      alist::push(sprites, ag);
    }
    break;
  }

  case tag_walk: {
    walk_t *aw = &(ae->u.walk);
    
    int dx, dy, sx, sy, sdx, sdy;
    if (dr.lev->travel(aw->srcx, aw->srcy, aw->d, dx, dy) &&
	dr.onscreen(aw->srcx, aw->srcy, sx, sy) &&
        dr.onscreen(dx, dy, sdx, sdy)) {

      /* -------------- new version ------------------ */
      int overlapy = 0;

      Animation *af = 0;

      switch (aw->entt) {

#     define INPLACE(entcase, olap, basename)            \
      case entcase: {                                    \
	overlapy = olap;                                 \
        AFrame *wa = 0;                                 \
	switch (aw->d) {                                  \
	 default:                                        \
	 case DIR_UP: wa = basename ## backward; break;  \
	 case DIR_DOWN: wa = basename ## forward; break; \
	 case DIR_RIGHT: wa = basename ## right; break;  \
	 case DIR_LEFT: wa = basename ## left; break;    \
	}                                                \
        af = new AnInPlace(sx, sy - overlapy, 1, wa);    \
        }                                                \
	break

	INPLACE(B_PLAYER, GUY_OVERLAPY, frames_walk);
	INPLACE(B_DALEK, DALEK_OVERLAPY, frames_dalek);
	INPLACE(B_HUGBOT, HUGBOT_OVERLAPY, frames_hugbot);
	/* actually, these should be done as below with fly */
	INPLACE(B_DALEK_ASLEEP, DALEK_OVERLAPY, frames_dalek_asleep);
	INPLACE(B_HUGBOT_ASLEEP, HUGBOT_OVERLAPY, frames_hugbot_asleep);
	INPLACE(B_BROKEN, BROKEN_OVERLAPY, frames_deadrobot);

#      undef INPLACE

      default:
	if (Level::isbomb(aw->entt)) {

	  overlapy = BOMB_OVERLAPY;

	  af = new AnFlying(pic_bomb_lit[aw->data][0],
			    sx, sy - BOMB_OVERLAPY,
			    aw->d,
			    TILESIZE(aw->d),
			    WALKPUSH_DIST, WALKPUSH_WAIT);
	  break;
	} 
	/* else FALLTHROUGH */
      case B_DELETED:
      case B_BOMB_X:
	af = new AnInPlace(sx, sy, 1, frames_error);
      }

      if (!af) break;

      AnFinale *ag = new AnFinale(FACING_FRAME(aw->d, aw->entt, aw->data),
				   sdx, sdy - overlapy);
      
      af->next = ag;
      
      /* walking is a sprite! */
      alist::push(sprites, af);
    }
    break;
  }

  } /* Switch anim tag */
}

bool AnFlying::init(unsigned int now) {
  nexttick = now;

  px = sx;
  py = sy;
  
  return false;
}

AnFlyingTile::AnFlyingTile(int ti_,
			   int sx, int sy, 
			   dir dd, int sdist,
			   int sp, int w)
  : AnFlying(0, sx, sy, dd, sdist, sp, w) {
  ti = ti_;
}

/* perhaps upgrade this to allow aframes instead of just surfaces */
AnFlying::AnFlying(SDL_Surface *what, int sx_, int sy_, dir dd, int sdist,
		   int sp, int w) 
  : sx(sx_), sy(sy_), d(dd), pleft(sdist) {

  above = what;
  
  speed = sp;
  wait = w;
}

bool AnFlying::think(unsigned int now) {
  /* are we done? */
  if (pleft <= 0) {
    return true;
  }
    
  /* should probably compute based on the
     number of frames we missed, too */
  int go = util::minimum(speed, pleft);

  {
    int dx = 0, dy = 0;
    dirchange(d, dx, dy);
    px += dx * go;
    py += dy * go;
  }

  pleft -= go;

  /* set timer */
  nexttick = now + wait + AN_SLOW;

  /* more */
  return false;
}

void AnFlying::draw() {
  /* we save position, so this is easy */
  blit(px, py);
}


/* generate the surfaces and aframes for
   flips. Each tile has two animations 
   ('in' and 'out'), each of which has 
   frames. 

   'out' looks like this:

		   ;,        ;
      +-----+      | `.      |
      |     |  ->  |  |  ->  |
      |     |      |  .      |
      +-----+      |,'       ;
			     '
*/
bool Animation::init_flips() {

  pic_flips_out_data =
    (SDL_Surface**)
    malloc (NUM_TILES * NUM_FLIPFRAMES * sizeof(SDL_Surface *));
  
  pic_flips_in_data =
    (SDL_Surface**)
    malloc (NUM_TILES * NUM_FLIPFRAMES * sizeof(SDL_Surface *));

  frame_flips_out =
    (AFrame**) malloc (NUM_TILES * sizeof(AFrame*));

  frame_flips_in =
    (AFrame**) malloc (NUM_TILES * sizeof(AFrame*));

  if (!(pic_flips_out_data && pic_flips_in_data && frame_flips_out
	&& frame_flips_in)) return false;

  SDL_Surface *tsrc = sdlutil::makesurface(TILEW, TILEH);
  sdlutil::clearsurface(tsrc, 0xFFFFFFFF);

  
  int pe = SDL_GetTicks() + (PROGRESS_TICKS * 2);
  for (int t = 0; t < NUM_TILES; t++) {
    Progress::drawbar((void*)&pe, t, NUM_TILES, "");

    /* space for frames */
    frame_flips_in[t] =
      (AFrame*) malloc ((NUM_FLIPFRAMES + 1) * sizeof(AFrame));
    frame_flips_out[t] =
      (AFrame*) malloc ((NUM_FLIPFRAMES + 1) * sizeof(AFrame));


    /*
      .               _,++''  .
      .           ,+'`         . 1
      .          -----------  .
      .       f  0        1.0
      .       -
      .    num_ff
      .
    */

    /* cut out tile to start */
    drawing::drawtile(0, 0, t, 0, tsrc);
    /* also a reversed one */
    SDL_Surface *tsrcr = sdlutil::fliphoriz(tsrc);

    /* flip_out is normal */
    for (int f = 0; f < NUM_FLIPFRAMES; f++) {

      float dist = ((float)f / NUM_FLIPFRAMES) * (UTIL_PI * 0.5f);
      
      int overlap = (int) (sin(dist) * FLIP_PIXELS_OVERLAP);

      /* XX shouldn't actually go to 0 */
      int width = (int)(cos(dist) * (float)TILEW);
      if (width <= 0) width = 1;
 
      pic_flips_out(t, f) =
	pitched_rect(width, TILEH, TILEH + overlap * 2, tsrc);

      /* put in the frames */
      frame_flips_out[t][f].pic = &pic_flips_out(t, f);
      frame_flips_out[t][f].x = (TILEW - width) >> 1;
      frame_flips_out[t][f].y = -overlap;
      frame_flips_out[t][f].wait = f?FLIP_SPEED:0;

      /* to avoid writing pitched_rect twice, we
	 flip, pitch, then flip back */
      SDL_Surface *tmp = 
	pitched_rect(width, TILEH, TILEH + overlap * 2, tsrcr);

      int fr = (NUM_FLIPFRAMES - (f + 1));

      pic_flips_in(t, fr) = sdlutil::fliphoriz(tmp);
      SDL_FreeSurface(tmp);
	
      frame_flips_in[t][fr].pic = &pic_flips_in(t, fr);
      frame_flips_in[t][fr].x = (TILEW - width) >> 1;
      frame_flips_in[t][fr].y = -overlap;
      frame_flips_in[t][fr].wait = fr?FLIP_SPEED:0;

    }

    /* set terminator frames */
    frame_flips_out[t][NUM_FLIPFRAMES].pic = 0;
    frame_flips_out[t][NUM_FLIPFRAMES].x = 0;
    frame_flips_out[t][NUM_FLIPFRAMES].y = 0;
    frame_flips_out[t][NUM_FLIPFRAMES].wait = FLIP_SPEED;
    
    frame_flips_in[t][NUM_FLIPFRAMES].pic = 0;
    frame_flips_in[t][NUM_FLIPFRAMES].x = 0;
    frame_flips_in[t][NUM_FLIPFRAMES].y = 0;
    frame_flips_in[t][NUM_FLIPFRAMES].wait = FLIP_SPEED;

      
    SDL_FreeSurface(tsrcr);
  }
  SDL_FreeSurface(tsrc);

  
  return true;
}

/* XXX might look better if it faded to black
   (or alpha) by depth after the midpoint */
/* generates a pitched rectangle (from left to right)
   at width w, that starts at height ph and is height
   h at the midpoint. */
SDL_Surface *Animation::pitched_rect(int w, int h, int ph, 
				      SDL_Surface *src,
                                      int oversample) {
  
  /* oversample by this amount */
  int zf = oversample;

  w <<= zf;
  h <<= zf;
  ph <<= zf;

  SDL_Surface *dst = sdlutil::makesurface(w, ph);
  if (!dst) return dst;
  
  /* set totally transparent */
  sdlutil::clearsurface(dst, 0x0);
  //  sdlutil::clearsurface(dst, 0x99FF9999);

  /* now copy lines from src into dst, following
     the pitch */

  sdlutil::slock(src);
  sdlutil::slock(dst);

  int descent = (ph - h) * 2;

  /*
    .                    w
    .                 ```````  
    .            .....+,................
    .           .     | `+, ....        . descent
    .        ph.      |  | `+   .    ...
    .           .     |  |  |    . h
    .            .    |  |  +   .
    .            .    |  |,`   .
    .             .   |  + ....
    .             .   |,`
    .              ...+
  */

  /* go a column at a time. */
  for (int col = 0; col < w; col++) {
    /* we don't worry about anti-aliasing here.
       this is handled by down-sampling later. */

    int start = (int)(descent * ((float)col / w));
    int n = ph - (start * 2);

    int x = (int)(((float)col / w) * src->w);

    for (int i = 0; i < n; i++) {

      int y = (int)(((float)i / n) * src->h);

      Uint32 sc = sdlutil::getpixel(src, x, y);

      sdlutil::setpixel(dst, col, start + i, sc);
      
    }
  }

  sdlutil::sulock(dst);
  sdlutil::sulock(src);

  /* now resample down to nice size */
  while (zf--) {
    SDL_Surface *tmp = dst;
    dst = sdlutil::shrink50(dst);
    SDL_FreeSurface(tmp);
  }

  return dst;
}

void AnInPlace::erase(Dirt *dirty) {
  dirty->setdirty(bx, by, bw, bh);
}

bool AnInPlace::think(unsigned int now) {

  /* maybe done, or time to loop */
  if (!frames[cframe + 1].pic) {
    if (loopsleft) {
      loopsleft--;
      cframe = 0;
    } else return true;
  } else {
    cframe++;
  }

  nexttick = now + AN_SLOW + frames[cframe + 1].wait;
  return false;
}

void AnInPlace::draw() {
  int fr = cframe;
  SDL_Rect rd;
  rd.x = xpos + frames[fr].x;
  rd.y = ypos + frames[fr].y;
  SDL_BlitSurface(*frames[fr].pic, 0, screen, &rd);
}

bool AnInPlace::init(unsigned int now) {
  /* find the minimum offset and max size of each frame.
     this is the region that we mark dirty each time. */

  int minx = 0, miny = 0;
  int maxx = 0, maxy = 0;

  for (int i = 0; frames[i].pic; i++) {
    if (frames[i].x < minx) minx = frames[i].x;
    if (frames[i].y < miny) miny = frames[i].y;

    if ((*frames[i].pic)->w + frames[i].x > maxx)
      maxx = (*frames[i].pic)->w + frames[i].x;
    if ((*frames[i].pic)->h + frames[i].y > maxy)
      maxy = (*frames[i].pic)->h + frames[i].y;
  }
  
  bx = xpos + minx;
  by = ypos + miny;
  bw = maxx - minx;
  bh = maxy - miny;

  cframe = 0;
  nexttick = now + frames[1].wait;

  return false;
}

/* right now this is just the guy, but
   it should include robots (etc.)
   later too */
void Animation::clearsprites(drawing &dr) {
  clearent(dr, dr.lev->guyx, dr.lev->guyy, GUY_OVERLAPY);
  for (int i = 0; i < dr.lev->nbots; i++) {
    int x, y;
    if (dr.lev->bott[i] != B_DELETED &&
	dr.lev->bott[i] != B_BOMB_X) {
      dr.lev->where(dr.lev->boti[i], x, y);
      /* can be conservative here so that we don't have to
	 dispatch on bot type */
      clearent(dr, x, y, MAX_OVERLAPY);
    }
  }
}

void Animation::clearent(drawing &dr, int entx, int enty, int overlap) {
  int sx, sy;

  int ta1 = dr.lev->tileat(entx, enty);
  if (dr.onscreen(entx, enty, sx, sy)) {
    if (ta1 == T_EXIT) {
      drawing::drawtileu(sx, sy, TU_EXITOPEN);
    } else {
      drawing::drawtile(sx, sy, ta1);
    }
  }

  if (enty > 0 && dr.onscreen(entx, enty - 1, sx, sy)) {
    int ta2 = dr.lev->tileat(entx, enty - 1);
    /* XXX draw openexit if ent above */
    if (ta2 == T_EXIT &&
	(dr.lev->botat(entx, enty - 1) ||
	 dr.lev->playerat(entx, enty - 1))) {
      drawing::drawtileu(sx, sy, TU_EXITOPEN);
    } else drawing::drawtile(sx, sy, ta2);
  } else if (enty == 0 && dr.onscreen(entx, enty, sx, sy)) {
    /* at top of screen, draw background */
    SDL_Rect dst;
    dst.x = sx;
    dst.y = sy - overlap;
    dst.w = TILEW;
    dst.h = overlap;
    SDL_FillRect(screen, &dst, BGCOLOR);
  }

}

void Animation::think_anims(alist **as, unsigned int now,
			    bool &remirror, bool done) {

  bool alldone = done;

  for (alist **tmp = as; *tmp;) {
    /* XXX depends on uninitialized values? */
    if ((*tmp)->head->nexttick <= now) {
      bool del = (*tmp)->head->think(now);

      if (!del) alldone = false;

      /* delete if done, but not finales. we take
	 care of those at the end */
      if (del && !(*tmp)->head->finale) {
	Animation *del = (*tmp)->head;
	/* another in line? */
	if (del->next) {
	  (*tmp)->head = del->next;
	  remirror = (*tmp)->head->init(now) || remirror;
	} else {
	  /* get rid of it */
	  *tmp = (*tmp)->next;
	}
	del->next = 0;
	delete del;
	/* don't advance; give this one a
	   chance to think */
	continue;
      }
    } else if (!(*tmp)->head->finale) alldone = false;
    /* advance */
    tmp = &((*tmp)->next);
  }

  /* if anything is in the list and we are alldone,
     then it must be a finale (otherwise it was
     deleted!) */
  if (alldone) {
    /* Assumes next fields are null */
    while (*as) {
      Animation *tmp = alist::pop(*as);
      /* don't draw any more. we just
	 prevent the screen from flipping at this point */
      // tmp->draw();
      delete tmp;
    }
  }
}

void Animation::draw_anims(alist *anims) {
  // printf("-- draw list %p\n", anims);
  for (alist *atmp = anims; atmp; 
      atmp = atmp->next) {
    // printf(" drawing %p (%s)\n", atmp->head, atmp->head->finale?"finale":"");
    atmp->head->draw();
  }
}

void Animation::erase_anims(alist *anims, Dirt *dirty) {
  for (alist *atmp = anims; atmp; atmp = atmp->next) {
    atmp->head->erase(dirty);
  }
}	

bool Animation::init_anims(alist *anims, unsigned int now) {
  /* initialize the animations */
  bool yes = false;
  for (alist *tmp = anims; tmp; tmp = tmp->next) {
    yes = tmp->head->init(now) || yes;
  }
  return yes;
}

void AnLaser::draw() {
  int chx = 0, chy = 0;
  dirchange(d, chx, chy);

  int px = sx;
  int py = sy;

  /* center on tile */
  px += (TILEW >> 1);
  py += (TILEH >> 1);

  sdlutil::slock(screen);

  /* we assume we're given a small enough ntiles so
     that this stays in the drawing area */
  /* XXX assumes tilew = tileh */
  int npix = (ntiles * TILEW) - (TILEW >> 1);

  {
    int ri, gi, bi;
    int ro, go, bo;

    /* modulate colors by cycle */
    if (cyclesleft & 1) {
      ri = rh;
      gi = gh;
      bi = bh;

      ro = rho;
      go = gho;
      bo = bho;
    } else {
      ri = rl;
      gi = gl;
      bi = bl;

      ro = rlo;
      go = glo;
      bo = blo;
    }

    while (npix--) {

      sdlutil::drawpixel(screen, px, py, ri, gi, bi);
      if (d == DIR_UP || d == DIR_DOWN) {
	sdlutil::drawpixel(screen, px - 1, py, ro, go, bo);
	sdlutil::drawpixel(screen, px + 1, py, ro, go, bo);
      } else {
	sdlutil::drawpixel(screen, px, py - 1, ro, go, bo);
	sdlutil::drawpixel(screen, px, py + 1, ro, go, bo);
      }

      px += chx;
      py += chy;
    }

  }

  sdlutil::sulock(screen);

}

bool AnLaser::think(unsigned int now) {
  if (!cyclesleft) return true;

  cyclesleft--;

  nexttick = now + LASER_TIME;
  return false;
}
