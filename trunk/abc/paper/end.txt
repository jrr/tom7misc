Anyway, to verify that PAPER.EXE is printable with no beeping or funny
characters, you could do

   COPY PAPER.EXE CON

to copy it to your console, or COPY PAPER.EXE LPT1 to copy it to your
simulated computer's printer (spoiler: It doesn't have one). But why
bother? You're reading PAPER.EXE right now!

I  used  DOSBox  frequently   during  development,  and  modified  its
debugger, especially for understanding  the header values are actually
used. The ABC compiler outputs  each of the intermediate languages for
a program  as it compiles,  as well as lightly-commented  X86 assembly
with address maps back into the  code segment, which makes it possible
to  easily  set  breakpoints  on  particular  pieces  of  code.  Since
compiling other people's software on Windows is a special nightmare, I
frequently  worked   inside  a  Linux  virtual   machine  (VirtualBox)
containing a DOS  virtual machine (DOSBox), a surreal  scenario that I
was  tickled to  find a  practical use  for. Let  us one  day simulate
Windows 7  on our iPhones  21 so that  we may render  this development
environment one level deeper.

My modifications to DOSBox are  included in the ABC source repository,
although they  are not  necessary to  run ABC-compiled  programs. When
running these programs under DOSBox with the debugger enabled, it will
complain  about a  "weird  header" when  loading  the program  (you're
tellin' me!) and the debugger will output the error

        Illegal/Unhandled opcode 63

upon exiting (because we do execute an illegal opcode). For cosmetic
style points, the local version of DOSBox has been modified to instead
output

        Thank you for playing Wing Commander!


    ** Future work **

There are many code size  optimizations possible, and while nontrivial
programs can fit in  64k (such as the one in  this paper), larger ones
will run up against that boundary  quickly. Probably a factor of about
4 can be gained through  a few hard but straightforward optimizations.
Can we  break free  of the  64k boundary? Earlier  we noted  that when
execution  exceeds CS:0xFFFF,  it  simply  continues to  CS:0x00010000
unless  a jump  is  executed  across that  boundary;  this address  is
pointing to  bytes that are  part of our  program image (this  text is
there,  in  fact),  so  conceivably  we could  write  code  here.  One
significant  issue is  that interrupts,  which are  constantly firing,
push  16-bit versions  of CS  and  IP onto  the stack,  and then  RETF
(return far) to that address. This  means that if an interrupt happens
while we are executing in this  extended address space, we will return
to CS:(IP & 0xFFFF). If we had control over interupts, this might be a
good way to return to the normal 16-bit code segment (i.e., to perform
a backwards  jump), but  as discussed, we  do not. We  may be  able to
globally  suppress  interupts,  like   by  using  our  single  illegal
instruction  interrupt  during   initialization,  with  the  interrupt
handler pointing  just to  code that we  control (and  never returning
from it).  This leaves the  interrupt flag cleared, as  discussed. The
computer will  be non-functional in  many ways, because  the operating
system  will  no  longer  run,  but  we might  still  be  able  to  do
rudimentary port-based  I/O, or build our  own non-interrupt-based OS.
With interrupts suppressed, we can't use the interrupt trick to return
to CS:0000. However,  my reading of the Intel manual  [XXX cite] seems
to imply  that a jump  performed from this  region can be  forced into
16-bit mode  (thus being  subject to  the &  0xFFFF overflow)  with an
address size  prefix; however, this  does not seem  to be the  case in
DOSBox. Given how unusual  this situation is, it may even  be a bug in
DOSBox's CPU  emulator. Having access to  a full megabyte of  code (it
still needs to  fit in the EXE container) would  be exciting, since it
would allow  us to build  much more significnt systems  (e.g. standard
malloc and a floating point emulator); more investigation is warranted
here.


I initially  designed CIL with the  thought that it could  be used for
multiple such  "compile C to  X" projects. These are  primarily jokes,
but   can   occasionally   be   of  legitimate   use   for   low-level
domain-specific tasks where the existence of a reasonable and familiar
high-level syntax  pays for  the effort of  writing a  simple backend.
(When making such a  decision I like to also weight  the effort by the
enjoyment of each task: i.e., the cost is like

   (1 - fun of writing backend) * time writing backend   vs
   (pain of writing low-level code by hand) *
       time writing low-level code by hand
       
... but  I have heard  that not all computer  work is done  purely for
fun.)  This "portable  assembler"  application of  C remains  relevant
today, and CIL or LLVMNOP is a much simpler than GCC or LLVM.

Anyway, I discovered that  the design of such a thing  is not so easy.
While it  is possible  to "compile away"  certain features  by turning
them into  something "simpler," it's not  straightforward what feature
set to  target. For example, for  ABC, we compile away  the | operator
into &, ^, -,  and +1. In another setting, | may  very well be present
instead of &.  We normally think of  the >> and <<  shift operators as
being  fundamental, but  in  ABC  they are  inaccessible.  I find  the
expression forms  like "a  < b"  much easier to  think about  then the
combined test-and-branch version,  but the latter is  much better when
targeting x86, and  important for producing reasonable code  in ABC. I
do think it would be possible to develop a simple and general language
for  this niche  where certain  constructs could  be compiled  away in
favor of others,  at the direction of the compiler  author, but such a
thing is firmly future work.


On that topic, one  might ask: What is the minimal  subset of bytes we
could imagine using?

There  are  some  trivial  subtractions:   We  never  emit  the  BOUND
instruction (0x62, lowercase b) and it  does not seem useful; a few of
the segment prefix instructions are also unused. The instructions like
"ASCII Adjust After Addition" are currently unused, but since they act
on AX  in a predictable  way, they could  provide ways to  improve the
routines to  load immediate values.  But we're talking  about reducing
the  surface, not  increasing it.  And speaking  of loading  immediate
values, we do certainly make use  of the entire set of printable bytes
in these routines  (as arguments to XOR, SUB, PUSH,  etc.), but on the
other hand, we can also reach any value from a known starting point by
INC and DEC, taking at most  0x7FFF instructions (half the size of the
code segment, unfortunately).  More essential is our ability  to set a
register to a known value, which  today requires two or more printable
values whose bitwise AND is 0.  Sadly, though we could go through some
pains to remove bytes from the gamut here and there, no natural subset
like  "only  lowercase  letters"  or "alphanumeric"  jumps  out  as  a
straightforward extension;  we rely  on the control  flow in  the late
lowercase letters  (Jcc) and  the basic ops  in the  early punctuation
(AND/XOR), not to mention that the  EXE header barely works within the
existing constraints with access to  both "small" (0x2020) and "large"
(0x7e7e) constants.

Others  have produced  compilers  for high-level  languages with  very
reduced instruction sets.  In an extreme case, Dolan  shows [XXX cite]
that the mov  instruction on its own is  Turing-complete (note however
that this requires a "single absolute jump" to the top of the program,
an issue similar to what we encounter in printable x86, only we do not
insert  any illegal  instructions).  Another enterprising  programmer,
Domas, implemented a C compiler that produces only MOV instructions. I
didn't look  at it while writing  ABC (spoilers!) but he  avoids using
any JMP instruction  the same way that I exit  the program (generating
illegal  instructions  but  rewriting the  interrupt  handler).  While
awesome, the problem is somewhat  different from what ABC solves; here
we  are  fundamentally  concerned  with   what  bytes  appear  in  the
executable, which  influences what  opcodes are accessible  (and their
arguments  and  addressing modes),  but  is  not the  only  constraint
created. For  example, in  MOV-only compilation, the  program's header
does  not  need to  consist  only  of  MOV  instructions, and  so  the
compiler's  output does  not  suffer  the same  severe  code and  data
limitations  that  DOS  EXEs  do. (The  executables  it  produces  are
extremely   large  and   slow;  they   also  seem   to  have   non-MOV
initialization code.)  The MOV instruction  is also very rich,  and no
versions of it are printable!

Of course,  everyone knows  that even unary  numbers (just  one symbol
repeated  a given  number  of  times) is  Turing  complete, via  Godel
encoding. So what's the big deal?


Here's the program:
%insert paper.c
That was it!

                                                                           
                                                                           
         ##       ##                                                       
          ###   ####                                                       
           ### ###                                                         
             ###                                                           
            #####                 ############                             
          ###  ###             #####         #########                     
         ##      ###          ###                    #########             
                             ###                          #####            
                  #####      ##                           ##%##            
   ########      ### =###   ##                           ##%%###           
  ###    ###    ##         ###                          ##%%###            
  ##      ##   ###         ##                          ##%%%##             
  ##     ###   ########    ##                          ##%###              
   =#######=   ##=   ##    ##                         ##%%##               
   ###    ###  ##    ##   ##                         ##%%###               
   ##     ###  ########   ##                         ##%%##                
   ##    ###     ####     ##                         ##%%##                
    #######            ########                      ##%%##                
                      ###%%####                    ########                
           ###########################            ####%%%##                
         ####-----------##%%%%%%%%%%%%##################%%#                
        ###-------------##%%%%%%%%%%%%%%%%%%%%%%%%%##--################    
       ###--------------###%%%%%%%%%%%%%%%%%%%%%%%###--------------#####   
      ##-----------------###%%%%%%%%%%%%%%%%%%%%####-------------###%%##   
     ##--------------------#####%%%%%%%%%%%#######--------------###%%%##   
    ###-----------------------##############-------------------###%%%%%##  
    ##====----------------------------------------------------###%%%%%%##  
   ###=========-----------------------------------------------##%%%%%%%##  
   ##===============------------------------------------=====##%%%%%%%%##  
   ##============================--------------==============##%%%%%%%%##  
   ###=======================================================##%%%%%%%%##  
   ###=======================================================##%%%%%%%%##  
    ##=======================================================##%%%%%%%%%## 
    ##=============================================%%###=====##%%%%%%%%### 
    ##=============================================##   ##===##%%%%%%%###  
    ##============================================%%#####%%==##%%%%%%###---
      #####========#########=================================##%%%%%##-----
         #########=##------############################======##%%%###----- 
             ########               ----------------#######=##%%###------  
            #######      ====                      ##########%%##------    
           ########         ======                 ######---###-------     
          ########    ==------          ========   ######----------        
         #######   ==========           =-----=   ######--------           
          #####                        ===        ######-------            
           ###   ========== ==       =------==   ######--------            
          ###                      ==========    ##--------                
          ##                                    ##-------                  
         ##     ==   ======                    ##-------                   
       ### ==========   ----=======       ==   ##-------                   
      ###            ===========    ===--     ##-------                    
      #############              === === ===  #---                         
                  ################           ##                            
                                 ##############                            

              Figure 7. Printable X86


    ** Acknowledgements **

The author would like to thank the fastidious SIBOVIK "Program" Committee
for "Evaluating" my paper.


    ** Bibliography **

# -------------------------------------------------------------------------

[X] Tom Murphy VII. "New results in k/n Power-Hours." SIGBOVIK,
    April 2014.

[X] Tom Murphy VII. "Modal Types for Mobile Code." Ph.D. thesis, Carnegie
    Mellon University, January 2008. Technical report CMU-CS-08-126.

[LLVM] Chris Lattner and Vikram Avde. "LLVM: A Compilation Framework for
       Lifelong Program Analysis and Transformation." CGO, March 2004.

[CKIT] David Ladd, Satish Chandra, Michael Siff, Nevin Heintze, Dino Oliva,
       and Dave MacQueen. "Ckit: A front end for C in SML." March 2000.
       http://smlnj.org/doc/ckit/

[INTC] Intel Corporation. "IA-32 Intel Architecture Software Developer's
       Manual. Volume 2: Instruction Set Reference." 2001.

[ABC] Steve Mansfield. "How to interpret abc music notation." 2005.

[MOV] Stephen Dolan. "mov is Turing-complete". 2013.

[MVF] Chris Domas. "M/o/Vfuscator2". August 2015.
      https://github.com/xoreaxeaxeax/movfuscator
      


Please see http://tom7.org/abc for supplemental material.
