

ascii


"trivial" with self-modifying code. Just a small boot-loader that
decodes regular x86 code from e.g. base64 or hex encoding. (This is
still hard because all the modern headers use zeroes?)


Control.Print.printDepth := 100;




Comprehensive opcode encoding reference:
http://ref.x86asm.net/geek32.html


Printable characters are 0x20 (space) through 0x7e (~), inclusive,
plus maybe 0x0D (CR), 0x0A (LF), 0x09 (TAB).


0x0A, 0x0D, 0x09 are all OR opcodes.

Tricks:
 - Though we have some limitations in the encoding of register
   targets, we can permute/copy between registers using the
   PUSH and POP instructions (0x50+r, 0x58+r).
 - Loading literals:
      XOR REG, REG
      XOR REG, IMM   (8, 16, 32 bits possible)
      there is also PUSH of immediates
 - Math:
     We have IMUL, phew.
     DIV we'll have to do in software (don't even have shifts for
     division by power of two)
     ADD (a, b) is the same as SUB (a, -b) as long as 
 - Bitwise complement:
     XOR REG, REG
     DEC REG  // now 0xFFFFFFFF
     XOR REG, REG2

Notable missing opcodes:
 - MOV. Ugh. Need this for...
     - loading literals
     - moving between registers
     - loading from and storing to memory
   ... looks like XOR with a memory operand and register known to
       contain 0 will work for loads and stores, though?
 - DIV and IDIV. Will need to do division in software, I guess.
 - CALL. We can probably manually push and jump.
 - RET*. We can probably manually pop and jump?
 - INT. Used to make DOS system calls, which might be important
   for setting up "unreal mode" (not to mention basic IO in DOS)
 - SHL and SHR, which are used all over the place. Since we also
   don't have ADD, this could make some normally easy
   things quite hard. Hmm. (We do have IMUL, INC and SUB, and can
   do bitwise complement with XOR.)

 - No two-byte opcodes can be used because these are prefixed
   with 0x0F.
   - These mostly look like fancy stuff
   - There are opcodes for setting up the LDT and GDT, which
     I think are needed to get into unreal mode. (Would need
     to use self-modifying code, or some other trick?)
   - SSE, MMX, VMX are here; stuff like CMOV that's useful
     but inessential.
   - "Jump short" instructions

32-bit ModR/M byte table.
ASCII values marked with *.
http://www.c-jump.com/CIS77/CPU/x86/X77_0090_addressing_modes.htm

r8(/r)                            AL  CL  DL  BL  AH  CH  DH  BH
r16(/r)                           AX  CX  DX  BX  SP  BP  SI  DI
r32(/r)                           EAX ECX EDX EBX ESP EBP ESI EDI
mm(/r)    MM?                     MM0 MM1 MM2 MM3 MM4 MM5 MM6 MM7
xmm (/r) XMM?                       0   1   2   3   4   5   6   7
sreg                               ES  CS  SS  DS  FS  GS res res
eee                               CR0 inv CR2 CR3 CR4 inv inv inv
eee                               DR0 DR1 DR2 DR3 DR4 DR5 DR6 DR7
(In decimal) /digit (Opcode)        0   1   2   3   4   5   6   7
(In binary) REG =                 000 001 010 011 100 101 110 111
Effective Address      Mod  R/M   Value of ModR/M Byte (in Hex)
[EAX]                   00  000   00  08  10  18 *20 *28 *30 *38
[ECX]                       001   01 ?09  11  19 *21 *29 *31 *39
[EDX]                       010   02 ?0A  12  1A *22 *2A *32 *3A
[EBX]                       011   03  0B  13  1B *23 *2B *33 *3B
[sib]                       100   04  0C  14  1C *24 *2C *34 *3C
disp32                      101   05 ?0D  15  1D *25 *2D *35 *3D
[ESI]                       110   06  0E  16  1E *26 *2E *36 *3E
[EDI]                       111   07  0F  17  1F *27 *2F *37 *3F
[EAX]+disp8             01  000  *40 *48 *50 *58 *60 *68 *70 *78
[ECX]+disp8                 001  *41 *49 *51 *59 *61 *69 *71 *79
[EDX]+disp8                 010  *42 *4A *52 *5A *62 *6A *72 *7A
[EBX]+disp8                 011  *43 *4B *53 *5B *63 *6B *73 *7B
[sib]+disp8                 100  *44 *4C *54 *5C *64 *6C *74 *7C
[EBP]+disp8                 101  *45 *4D *55 *5D *65 *6D *75 *7D
[ESI]+disp8                 110  *46 *4E *56 *5E *66 *6E *76 *7E
[EDI]+disp8                 111  *47 *4F *57 *5F *67 *6F *77  7F
[EAX]+disp32            10  000   80  88  90  98  A0  A8  B0  B8
[ECX]+disp32                001   81  89  91  99  A1  A9  B1  B9
[EDX]+disp32                010   82  8A  92  9A  A2  AA  B2  BA
[EBX]+disp32                011   83  8B  93  9B  A3  AB  B3  BB
[sib]+disp32                100   84  8C  94  9C  A4  AC  B4  BC
[EBP]+disp32                101   85  8D  95  9D  A5  AD  B5  BD
[ESI]+disp32                110   86  8E  96  9E  A6  AE  B6  BE
[EDI]+disp32                111   87  8F  97  9F  A7  AF  B7  BF
AL/AX/EAX/ST0/MM0/XMM0  11  000   C0  C8  D0  D8  E0  E8  F0  F8
CL/CX/ECX/ST1/MM1/XMM1      001   C1  C9  D1  D9  E1  E9  F1  F9
DL/DX/EDX/ST2/MM2/XMM2      010   C2  CA  D2  DA  E2  EA  F2  FA
BL/BX/EBX/ST3/MM3/XMM3      011   C3  CB  D3  DB  E3  EB  F3  FB
AH/SP/ESP/ST4/MM4/XMM4      100   C4  CC  D4  DC  E4  EC  F4  FC
CH/BP/EBP/ST5/MM5/XMM5      101   C5  CD  D5  DD  E5  ED  F5  FD
DH/SI/ESI/ST6/MM6/XMM6      110   C6  CE  D6  DE  E6  EE  F6  FE
BH/DI/EDI/ST7/MM7/XMM7      111   C7  CF  D7  DF  E7  EF  F7  FF


SIB (scaled index byte) table
http://www.c-jump.com/CIS77/CPU/x86/X77_0100_sib_byte_layout.htm

r32                       EAX ECX EDX EBX ESP alt ESI EDI
(In decimal) Base =       0   1   2   3   4   5   6   7
(In binary) Base =        000 001 010 011 100 101 110 111
Scaled Index  SS  Index   Value of SIB Byte (in Hexadecimal)
[EAX]         00  000     00  01  02  03  04  05  06  07
[ECX]             001     08 ?09 ?0A  0B  0C ?0D  0E  0F
[EDX]             010     10  11  12  13  14  15  16  17
[EBX]             011     18  19  1A  1B  1C  1D  1E  1F
none              100    *20 *21 *22 *23 *24 *25 *26 *27
[EBP]             101    *28 *29 *2A *2B *2C *2D *2E *2F
[ESI]             110    *30 *31 *32 *33 *34 *35 *36 *37
[EDI]             111    *38 *39 *3A *3B *3C *3D *3E *3F
[EAX*2]       01  000    *40 *41 *42 *43 *44 *45 *46 *47
[ECX*2]           001    *48 *49 *4A *4B *4C *4D *4E *4F
[EDX*2]           010    *50 *51 *52 *53 *54 *55 *56 *57
[EBX*2]           011    *58 *59 *5A *5B *5C *5D *5E *5F
none              100    *60 *61 *62 *63 *64 *65 *66 *67
[EBP*2]           101    *68 *69 *6A *6B *6C *6D *6E *6F
[ESI*2]           110    *70 *71 *72 *73 *74 *75 *76 *77
[EDI*2]           111    *78 *79 *7A *7B *7C *7D *7E  7F
[EAX*4]       10  000     80  81  82  83  84  85  86  87
[ECX*4]           001     88  89  8A  8B  8C  8D  8E  8F
[EDX*4]           010     90  91  92  93  94  95  96  97
[EBX*4]           011     98  99  9A  9B  9C  9D  9E  9F
none              100     A0  A1  A2  A3  A4  A5  A6  A7
[EBP*4]           101     A8  A9  AA  AB  AC  AD  AE  AF
[ESI*4]           110     B0  B1  B2  B3  B4  B5  B6  B7
[EDI*4]           111     B8  B9  BA  BB  BC  BD  BE  BF
[EAX*8]       11  000     C0  C1  C2  C3  C4  C5  C6  C7
[ECX*8]           001     C8  C9  CA  CB  CC  CD  CE  CF
[EDX*8]           010     D0  D1  D2  D3  D4  D5  D6  D7
[EBX*8]           011     D8  D9  DA  DB  DC  DD  DE  DF
none              100     E0  E1  E2  E3  E4  E5  E6  E7
[EBP*8]           101     E8  E9  EA  EB  EC  ED  EE  EF
[ESI*8]           110     F0  F1  F2  F3  F4  F5  F6  F7
[EDI*8]           111     F8  F9  FA  FB  FC  FD  FE  FF

alt:
00 = disp32
01 = ebp+disp8
10 = ebp+disp32
