
#include <vector>
#include <string>
#include <algorithm>
#include <cstdint>
#include <memory>

#include "timer.h"
#include "font-problem.h"

#include "image.h"
#include "lines.h"
#include "base/stringprintf.h"

#include "threadutil.h"

using namespace std;

using uint8 = uint8_t;
using uint32 = uint32_t;
using int64 = int64_t;


// XXX somehow needs to be shared?
static constexpr int ROW0_MAX_PTS = 38;
static constexpr int ROW1_MAX_PTS = 14;
static constexpr int ROW2_MAX_PTS = 10;
constexpr std::initializer_list<int> row_max_points = {
  ROW0_MAX_PTS,
  ROW1_MAX_PTS,
  ROW2_MAX_PTS,
};


struct Op {
  char input_char;
  char output_char;
  Op(char i, char o) : input_char(i), output_char(o) {}
};

struct Config {
  string font_name = "Perfect Hallucination";
  string filename = "perfect.sfd";
  float baseline = 0.75f;
  float extra_scale = 1.0f;
  float linegap = 0.0f;
  float blank_width = 1.0f;

  // generated by hallucinate.exe
  vector<pair<char, uint64>> chars = {
    {'A', 0xe37f7e38383c1c08},
    {'B', 0x58d81c783ebb1f18},
    {'C', 0x7c7e0f0f07041e7c},
    {'D', 0x989c9c387c3c1f0f},
    {'E', 0x70503e1e1e5f1f38},
    {'F', 0x0600feff1f070373},
    {'G', 0x707c7ece0c0e0cfc},
    {'H', 0x870f0fef3f0c4b02},
    {'I', 0xf0f47c3818187c5f},
    {'J', 0x3c7e7cf170f0f880},
    {'K', 0x825e3f3f3778d800},
    {'L', 0x7e7e1edf0e0e1f00},
    {'M', 0x829efef67c648083},
    {'N', 0x41787c7e6e2e068e},
    {'O', 0x2002fede4cee7c70},
    {'P', 0x000878f8e0f37f3f},
    {'Q', 0xbc3f37c646464634},
    {'R', 0x80032a7e7e1e7e1e},
    {'S', 0x4cfcf8fe7f080820},
    {'T', 0x181838387f7b7963},
    {'U', 0x287f7f1e1c9e9801},
    {'V', 0x0e1e1eff7b03c700},
    {'W', 0x487ffffef0800180},
    {'X', 0xe67c7c78787c40c8},
    {'Y', 0x3070787c7e66e2e4},
    {'Z', 0x228e8e1c787e7e86},

    {'a', 0xccce6030761e1800},
    {'b', 0x1f9f5e4200020e06},
    {'c', 0xc7e1e060070383c},
    {'d', 0x840c063f38786070},
    {'e', 0xccc00027e3e1e10},
    {'f', 0x4e0c1910f1f0f8},
    {'g', 0xfad8383e84848010},
    {'h', 0x6cccf0f872300004},
    {'i', 0x8f8403a1838381f},
    {'j', 0x74f0f16005070107},
    {'k', 0x8280061e0f4f0706},
    {'l', 0xf0dc5858183c3010},
    {'m', 0x8282e2c0db1f0610},
    {'n', 0x2c28260607efc30},
    {'o', 0x701c00c6ce0f3c00},
    {'p', 0x60c00c0c753707e},
    {'q', 0x303232e260e0fc18},
    {'r', 0x100c0e1cfc3c2e20},
    {'s', 0xc404030fe9cbe08},
    {'t', 0x18981c1e1f4c1e},
    {'u', 0x507c7c747840c800},
    {'v', 0x87c6c60667cc4},
    {'w', 0x1e4466666061e0c0},
    {'x', 0x70717c3c1c1c0110},
    {'y', 0x40078f9f1fc8008},
    {'z', 0x8c3f1c606072f000},
    
    {' ', 0x0000000000000000},
  };
};

static bool IsUppercase(char c) {
  return (c >= 'A' && c <= 'Z');
}

static bool IsLowercase(char c) {
  return (c >= 'a' && c <= 'z');
}

static bool IsLetter(char c) {
  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

static constexpr FontProblem::SDFConfig SDF_CONFIG = {};

// Just making a TTF from precomputed bitmaps.
static void GenerateOne(Config cfg) {
  std::mutex out_m;

  vector<pair<char, TTF::Char>> chars =
    ParallelMap(cfg.chars,
                [&](pair<char, uint64> letter) {
                  const int codepoint = letter.first;
                  FontProblem::Image8x8 img8(letter.second);

                  // XXX Of course we could trace the bitmap directly,
                  // and this would produce more faithful results!
                  // Fake SDF.
                  ImageF sdf(
                      IsUppercase(codepoint) ? 
                      FontProblem::SDF36From8x8Uppercase(img8) :
                      FontProblem::SDF36From8x8Lowercase(img8));

                  const auto [unopt_contours, contours] =
                    FontProblem::VectorizeSDF(SDF_CONFIG, sdf);
                  // XXX tune
                  const float right_edge = 4 + 22 + 2;
                  TTF::Char ttf_char =
                    FontProblem::ToChar(SDF_CONFIG, contours, right_edge);

                  // XXX hax
                  TTF::MapCoords(
                      [&cfg](float x, float y) {
                        return make_pair(x + 4.0f/36.0f, y);
                      }, &ttf_char);
                  
                  return make_pair((char)codepoint, ttf_char);
                },
                13);

  TTF::Font font;
  font.baseline = cfg.baseline;
  font.linegap = cfg.linegap;
  font.extra_scale = cfg.extra_scale;
  for (const auto &[c, ch] : chars) font.chars[c] = ch;

  Util::WriteFile(cfg.filename, font.ToSFD(cfg.font_name));
  printf("Wrote %s\n", cfg.filename.c_str());
}

int main(int argc, char **argv) {

  GenerateOne(Config());

  return 0;
}
