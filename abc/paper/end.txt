Anyway, to verify that PAPER.EXE is printable with no beeping or funny
characters, you could do

   COPY PAPER.EXE CON

to copy it to your console, or COPY PAPER.EXE LPT1 to copy it to your
simulated computer's printer (spoiler: It doesn't have one). But why
bother? You're reading PAPER.EXE right now!

I  used  DOSBox  frequently   during  development,  and  modified  its
debugger, especially for understanding  the header values are actually
used. The ABC compiler outputs  each of the intermediate languages for
a program  as it compiles,  as well as lightly-commented  X86 assembly
with address maps back into the  code segment, which makes it possible
to  easily  set  breakpoints  on  particular  pieces  of  code.  Since
compiling other people's software on Windows is a special nightmare, I
frequently  worked   inside  a  Linux  virtual   machine  (VirtualBox)
containing a DOS  virtual machine (DOSBox), a surreal  scenario that I
was  tickled to  find a  practical use  for. Let  us one  day simulate
Windows 7  on our iPhones  21 so that  we may render  this development
environment one level deeper.

My modifications to DOSBox are  included in the ABC source repository,
although they  are not  necessary to  run ABC-compiled  programs. When
running these programs under DOSBox with the debugger enabled, it will
complain  about a  "weird  header" when  loading  the program  (you're
tellin' me!) and the debugger will output the error

        Illegal/Unhandled opcode 63

upon exiting (because we do execute an illegal opcode). For cosmetic
style points, the local version of DOSBox has been modified to instead
output

        Thank you for playing Wing Commander!


    ** Future work **

I initially  designed CIL with the  thought that it could  be used for
multiple such  "compile C to  X" projects. These are  primarily jokes,
but   can   occasionally   be   of  legitimate   use   for   low-level
domain-specific tasks where the existence of a reasonable and familiar
high-level syntax  pays for  the effort of  writing a  simple backend.
(When making such a  decision I like to also weight  the effort by the
enjoyment of each task: i.e., the cost is like

   (1 - fun of writing backend) * time writing backend   vs
   (pain of writing low-level code by hand) *
       time writing low-level code by hand
       
... but  I have heard  that not all computer  work is done  purely for
fun.)  This "portable  assembler"  application of  C remains  relevant
today, and CIL or LLVMNOP is a much simpler than GCC or LLVM.

Anyway, I discovered that  the design of such a thing  is not so easy.
While it  is possible  to "compile away"  certain features  by turning
them into  something "simpler," it's not  straightforward what feature
set to  target. For example, for  ABC, we compile away  the | operator
into &, ^, -,  and +1. In another setting, | may  very well be present
instead of &.  We normally think of  the >> and <<  shift operators as
being  fundamental, but  in  ABC  they are  inaccessible.  I find  the
expression forms  like "a  < b"  much easier to  think about  then the
combined test-and-branch version,  but the latter is  much better when
targeting x86, and  important for producing reasonable code  in ABC. I
do think it would be possible to develop a simple and general language
for  this niche  where certain  constructs could  be compiled  away in
favor of others,  at the direction of the compiler  author, but such a
thing is firmly future work.


    ** Related work **

On that topic, one  might ask: What is the minimal  subset of bytes we
could imagine using?

There  are  some  trivial  subtractions;   we  never  emit  the  BOUND
instruction (0x62, lowercase b) and it  does not seem useful, a few of
the segment prefix instructions are also unused. The instructions like
"ASCII Adjust After Addition" are currently unused, but since they act
on AX  in a predictable  way, they could  provide ways to  improve the
routines to  load immediate values.  But we're talking  about reducing
the  surface, not  increasing it.  And speaking  of loading  immediate
values, we do certainly make use  of the entire set of printable bytes
in these routines  (as arguments to XOR, SUB, PUSH,  etc.), but on the
other hand, we can also reach any value from a known starting point by
INC and DEC, taking at most  0x7FFF instructions (half the size of the
code segment, unfortunately).  More essential is our ability  to set a
register to a known value, which  today requires two or more printable
values whose bitwise AND is 0.  Sadly, though we could go through some
pains to remove bytes from the gamut here and there, no natural subset
like  "only  lowercase  letters"  or "alphanumeric"  jumps  out  as  a
straightforward extension;  we rely  on the control  flow in  the late
lowercase letters  (Jcc) and  the basic ops  in the  early punctuation
(AND/XOR), not to mention that the  EXE header barely works within the
existing constraints with access to  both "small" (0x2020) and "large"
(0x7e7e) constants.

Others  have produced  compilers  for high-level  languages with  very
reduced instruction sets.  In an extreme case, Dolan  shows [XXX cite]
that the mov  instruction on its own is  Turing-complete (note however
that this requires a "single absolute jump" to the top of the program,
an issue similar to what we encounter in printable x86, only we do not
insert  any illegal  instructions).  Another enterprising  programmer,
Domas, implemented a C compiler that produces only MOV instructions. I
didn't look  at it while writing  ABC (spoilers!) but he  avoids using
any JMP instruction  the same way that I exit  the program (generating
illegal  instructions  but  rewriting the  interrupt  handler).  While
awesome, the problem is somewhat  different from what ABC solves; here
we  are  fundamentally  concerned  with   what  bytes  appear  in  the
executable, which  influences what  opcodes are accessible  (and their
arguments), but  is not the  only constraint created. For  example, in
MOV-only compilation,  the program's header  does not need  to consist
only of MOV instructions, and so the compiler's output does not suffer
the  same severe  code and  data limitations  that DOS  EXEs do.  (The
executables  it  produces  are  extremely large  and  slow.)  The  MOV
instruction is also very rich, and no versions of it are printable!

Of course,  everyone knows  that even unary  numbers (just  one symbol
repeated  a given  number  of  times) is  Turing  complete, via  Godel
encoding. So what's the big deal?


Here's the program:
%insert paper.c
That was it!

                                                                           
                                                                           
         ##       ##                                                       
          ###   ####                                                       
           ### ###                                                         
             ###                                                           
            #####                 ############                             
          ###  ###             #####         #########                     
         ##      ###          ###                    #########             
                             ###                          #####            
                  #####      ##                           ##%##            
   ########      ### =###   ##                           ##%%###           
  ###    ###    ##         ###                          ##%%###            
  ##      ##   ###         ##                          ##%%%##             
  ##     ###   ########    ##                          ##%###              
   =#######=   ##=   ##    ##                         ##%%##               
   ###    ###  ##    ##   ##                         ##%%###               
   ##     ###  ########   ##                         ##%%##                
   ##    ###     ####     ##                         ##%%##                
    #######            ########                      ##%%##                
                      ###%%####                    ########                
           ###########################            ####%%%##                
         ####-----------##%%%%%%%%%%%%##################%%#                
        ###-------------##%%%%%%%%%%%%%%%%%%%%%%%%%##--################    
       ###--------------###%%%%%%%%%%%%%%%%%%%%%%%###--------------#####   
      ##-----------------###%%%%%%%%%%%%%%%%%%%%####-------------###%%##   
     ##--------------------#####%%%%%%%%%%%#######--------------###%%%##   
    ###-----------------------##############-------------------###%%%%%##  
    ##====----------------------------------------------------###%%%%%%##  
   ###=========-----------------------------------------------##%%%%%%%##  
   ##===============------------------------------------=====##%%%%%%%%##  
   ##============================--------------==============##%%%%%%%%##  
   ###=======================================================##%%%%%%%%##  
   ###=======================================================##%%%%%%%%##  
    ##=======================================================##%%%%%%%%%## 
    ##=============================================%%###=====##%%%%%%%%### 
    ##=============================================##   ##===##%%%%%%%###  
    ##============================================%%#####%%==##%%%%%%###---
      #####========#########=================================##%%%%%##-----
         #########=##------############################======##%%%###----- 
             ########               ----------------#######=##%%###------  
            #######      ====                      ##########%%##------    
           ########         ======                 ######---###-------     
          ########    ==------          ========   ######----------        
         #######   ==========           =-----=   ######--------           
          #####                        ===        ######-------            
           ###   ========== ==       =------==   ######--------            
          ###                      ==========    ##--------                
          ##                                    ##-------                  
         ##     ==   ======                    ##-------                   
       ### ==========   ----=======       ==   ##-------                   
      ###            ===========    ===--     ##-------                    
      #############              === === ===  #---                         
                  ################           ##                            
                                 ##############                            

              Figure 7. Printable X86


    ** Acknowledgements **

The author would like to thank the fastidious SIBOVIK "Program" Committee
for "Evaluating" my paper.


    ** Bibliography **

# -------------------------------------------------------------------------

[X] Tom Murphy VII. "New results in k/n Power-Hours." SIGBOVIK,
    April 2014.

[X] Tom Murphy VII. "Modal Types for Mobile Code." Ph.D. thesis, Carnegie
    Mellon University, January 2008. Technical report CMU-CS-08-126.

[LLVM] Chris Lattner and Vikram Avde. "LLVM: A Compilation Framework for
       Lifelong Program Analysis and Transformation." CGO, March 2004.

[CKIT] David Ladd, Satish Chandra, Michael Siff, Nevin Heintze, Dino Oliva,
       and Dave MacQueen. "Ckit: A front end for C in SML." March 2000.
       http://smlnj.org/doc/ckit/

[INTC] Intel Corporation. "IA-32 Intel Architecture Software Developer's
       Manual. Volume 2: Instruction Set Reference." 2001.

[ABC] Steve Mansfield. "How to interpret abc music notation." 2005.

[MOV] Stephen Dolan. "mov is Turing-complete". 2013.

[MVF] Chris Domas. "M/o/Vfuscator2". August 2015.
      https://github.com/xoreaxeaxeax/movfuscator
      


Please see http://tom7.org/abc for supplemental material.
