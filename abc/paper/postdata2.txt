
Some low-level ideas are threaded throughout the compiler. In the case
of  "out8"  and  "exit",  for  example, these  are  available  to  the
programmer if she simply declares them:

     int _out8(int, int);
     int _exit(int);

They can  be called like _exit(1),  but are translated to  the Builtin
expression rather  than a function call.  It is not permitted  to take
their addresses.

Unlike LLVMNOP, we have both  expression forms of operators and "cond"
forms. The expression forms evaluate to 1 or 0, whereas the cond forms
are only used  as a combined test-and-branch in  the GotoIf construct.
Optimizations try to put these in the most useful form for later work.


    ** Optimization **

CIL code is optimized via a series of conservative transformations
until no more simplifications are possible. Among important
optimizations are dead variable removal and constant folding, which
clean up the code generated by the translation from C to CIL. Lots
more is possible here, but since these problems are not specific to
printable x86, I did not spend that much time on optimization. The
main thing is to keep the code size for the programs we want to write
under the 64k limit. There is a natural tension between implementing
optimizations for the "high-level" CIL language (which is easier to
analyze) and the low-level LLVMNOP language (more flexibility, access
to incidental tricks that don't make sense at the high level, and
opportunity to clean up after more of the compiler's work).

Optimizations are implemented using the "Pass" functor idea presented
in my Ph.D. dissertation [XXX cite].

The  optimization  phase  is  also responsible  for  eliminating  some
features from the  language so that we don't need  to think about them
when converting to LLVMNOP.  This includes transforming the comparison
ops like LessEq into GotoIf(cond, ...), replacing string literals with
references to globally-allocated arrays, and moving all initialization
code for globals into a wrapper  around the main function. These tasks
aren't  really optimizations,  but  we want  to continue  optimization
after doing them,  so optimization code needs to at  least be aware of
their existence  so that it  doesn't e.g. reintroduce  string literals
after they have been eliminated!


    ** Converting to CIL **

The frontend of the compiler uses the ckit library [XXX cite] to parse
the input C code into an ML datatype called "AST." The details of this
language  are  mostly  uninteresting,  but  it  is  mostly  in  direct
correspondence  to C89  itself.  When  we convert  to  CIL, we  remove
"syntactic sugar" constructs  that can be built  from more fundamental
things. "For"  example, a for loop  is broken apart into  a few gotos.
The && and || operators  make their short-circuiting behavior explicit
by sequencing the tests. Implicit widening and narrowing between types
is made explicit. Compound assigment ops  like ^= and ++ are sequenced
into the primitives that make  them up. Array subscripts and structure
references   [XXX  if   implemented?]  are   converted  into   pointer
arithmetic. Although there's a lot of code involved to implement C, it
is mostly standard.


    ** Limitations **

ABC has  some limitations, some of  which are fundamental and  some of
which are simply due to the unconscionably strict SIGBOVIK deadlines:

 - Floating point is not available. We have access to none of the
   floating point instructions, so native support is not really
   possible. It would be possible to provide software implementations
   of the floating-point operations
 - Standard libraries are not available. Since we can only call the
   DOS INT 0x21 handler one time, and we use that to exit, there is
   no way to access the filesystem or write to the console.
 - malloc/free. This can be supported in software, with no
   significant limitations other than the amount of memory available.
 - Multiplication. We have access to the IMUL instruction, but only
   versions that multiply by a constant immediate value (opcodes
   0x6B, 0x69). Since that immediate needs to be printable, we can't
   even necessarily use this instruction to implement multiplication
   by arbitrary constants.
 - Division. This needs to be done in software, which is trickier
   than usual due to the lack of efficient bit shifts. Note that
   many computer processors don't even have an integer division
   instruction (e.g. Alpha, 6502), so this is not even that weird.
 - Structs. These are not hard, and just need to be translated into
   pointer arithmetic in the frontend. I just didn't get to it. (XXX)
 - switch. Also easy; it just becomes an if-else chain. CIL even has
   the expressive power to implement jump tables, by computing and
   calling a function pointer.
 - sizeof. Actually sizeof is so easy I just went and implemented
   it just now, instead of writing this sentence. I saved further
   time by not deleting the previous sentence.
 - Bit fields. These are garbage so nobody implements them unless
   they have to. No fundamental limitation here, although the
   compiler does assume that lvalues have an address.

I am shamed that ABC does not compile the feasible subset. Perhaps
check http://tom7.org/abc/ for an updated version, published
postpartum.


    ** Programming **

Since we're working in reverse order,  we've reached the very front of
the ABC compiler, and now can talk about the program we feed to it.

(need to talk about io!) One could conceivably implement their own
file system and so on by using IN and OUT to write to hardware ports,
although most of this kind of work requires writing and invoking
interrupt handlers, which we cannot do.
