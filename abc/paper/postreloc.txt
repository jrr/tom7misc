
Sorry about that!

Not  all  of the  ASCII  bytes  are  considered printable,  either.  For
example, 0x14 means DEVICE CONTROL 4 in ASCII, forever enshrined as that
useless idea. Even DOS didn't think it was useful, so DOS prints it as a
"paragraph" symbol. The byte 0x07 just makes  a beep sound if you try to
display it.


The range of actually printable characters are:

   0x0A   NEWLINE
   0x0D.  CARRIAGE RETURN
   0x20.  SPACE
   ...    (all the keyboard characters are from 0x20-0x7e)
   0x7E.  ~

..  and no  others.  0x0A  and 0x0D  are  actually pretty  questionable,
because UNIX,  MacOS and DOS/Windows could  not agree on whether  a line
ends with newline, carriage return, or carriage return and then newline.
This paper  is concerned with  reliably printable characters, so  we say
that's the  95 characters from 0x20  to 0x7E, inclusive. This  is all of
'em, with the upper-left corner being 0x20 SPACE.

                 ! " # $ % & ' ( ) * + , - . / 0 1 2
               3 4 5 6 7 8 9 : ; < = > ? @ A B C D E
               F G H I J K L M N O P Q R S T U V W X
               Y Z [ \ ] ^ _ ` a b c d e f g h i j k
               l m n o p q r s t u v w x y z { | } ~


By  the way,  I tried  to  be disciplined  in this  paper about  writing
hexadecimal numbers  in C notation, like  0x42 to stand for  66. The x86
architecture  is little-endian,  so a  16-bit word  0x1234 is  stored in
memory as 0x34 0x12.  Also, when I write x86, that  is not a hexadecimal
number, that's the name of the computer architecture.


    ** 3. Printable x86 **

Since only 37%  of bytes are printable, if you  inspect (i.e., "cat") an
executable   program,  it   will  almost   always  contain   unprintable
characters, and may beep at you, etc. However, since the printable bytes
do stand for  some subset of X86 opcodes, it  is technically possible to
make X86 sequences  that are printable. One famous example  is the EICAR
Test File:

X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*

This string  is used to  test antivirus  software, because you  can hide
this string away inside some file and then see if the antivirus software
can successfully find  it (?). What's cool about this  string is that if
you stick  it in a  file called, say, EICAR.COM,  you can just  run that
file in DOS and it prints out

EICAR-STANDARD-ANTIVIRUS-TEST-FILE!

... as if you can't already just see that in the file.

The EICAR Test File is clever, but there are a few problems with it:

  - It was written by hand. Though it's easy to change the message
    it prints, everything else about it is extremely delicate.

  - Because it's in a COM file, it only has access to a single
    64k segment, which must hold the code, data, and stack.

  - Most damningly, like many viruses it uses "self-modifying code"
    to first rewrite itself into different opcodes. This means that
    the processor ends up executing several non-printable opcodes.
    This is like telling the waiter that you don't eat poultry but
    eggs are okay, and then they bring you an egg, but that egg
    hatches into a chicken right after they bring it to you. Come on.

In this  paper I present  a compiler  for the C89  programming language*
called ABC.  It produces completely  printable executables from  C code.
While self-modifying code is a powerful technique, it makes this problem
"too easy;" I  want to explore what programs can  be written natively in
the printable  subset of X86. Programs  compiled with ABC do  not modify
themselves,  or  cause  themselves  to be  modified;  every  instruction
program executes  (outside of  the operating  system) contains  only the
bytes  0x20-0x7E. Moreover,  every byte  in  the file  is printable,  so
programs can viewed as text.

Source code for this project is available at:   http://tom7.org/abc

* Not every C feature is implemented. Some of these are just not feasible
  and some I just didn't get to before the deadline. The shortcomings
  are discussed in Section XXX.


    ** 4. Difficulties **

This is a challenging programming problem!

  - Well, you have to write a compiler;
  
  - Due to some constraints, it has to produce reasonably good (small)
    code, or the compilation strategy will fail;
    
  - You only get a handful of instructions;
  
  - Some extremely important instructions are completely missing;
  
  - Notably, superficially you can't load arbitrary numbers into
    registers, jump backwards, or interact with the operating system;
    
  - Many remaining instructions can only be used in weird addressing modes;

  - Several standard techniques for assembling programs don't work
    due to the subset targeted;
    
  - The program's header must also be printable, which puts constraints
    on its size and layout;
    
  - Unreasonable SIGBOVIK policies require that papers not be xxx-tra
    large-size.

 +---------------------------------------------------------------------+
 | By now you've probably guessed from the gibberish you've been       |\
 | seeing that this paper is itself the output of ABC; that is, this   | |
 | this paper is also an executable file. If so, you guessed correct!! | |
 +---------------------------------------------------------------------+ |
  \_____________________________________________________________________\|




    ** 5. The CISC Ridiculous **

Let's look at  the printable opcodes available in  X86. Don't actually
read this table, but I will refer to it:

    20-23  AND reg|mod/rm
    24,25  AND AL/AX/EAX <- imm
       26  ES segment override prefix
       27  DAA Decimal Adjust AL after addition
    28-2B  SUB reg|mod/rm
    2C,2D  SUB AL/AX/EAX <- imm
       2E  CS segment override prefix
       2F  DAS Decimal Adjust AL after subtraction
    30-33  XOR reg|mod/rm
    34,35  XOR AL/AX/EAX <- imm
       36  SS segment override prefix
       37  AAA ASCII Adjust After Addition
    38-3B  CMP reg|mod/rm
    3C,3D  CMP AL/AX/EAX <- imm
       3E  DS segment override prefix
       3F  AAS ASCII Adjust After Subtraction
    40-47  INC multibyte register
    48-4F  DEC multibyte register
    50-57  PUSH multibyte register
    58-5F  POP multibyte register
       60  PUSHA Push all registers
       61  POPA Pop all register
       62  BOUND Check array index against bounds
       63  ARPL Adjust RPL field of segment selector
       64  FS segment override prefix
       65  GS segment override prefix
       66  operand size override prefix
       67  address size override prefix     
    68,6A  PUSH imm
       69  IMUL
    6C,6D  INS ES:DI <- DX
    6E,6F  OUTS DX <- DS:SI
    70-7E  Jcc+disp8 variants

    Figure 1. Instructions in printable x86

That's all  we get!  Many of  these opcodes take  arguments, such  as an
immediate byte (or word, or  double-word); for example the sequence 0x24
0x42 means AND AL <- 0x42. In  these cases, the arguments must of course
also be  printable, which  limits what  we can  do with  them, sometimes
severely.

It's not clear that  it will even be possible to  do basic things, and
it  was a  pretty  satisfying  hacking challenge  to  work around  its
limitations. If you have some  x86 assembly experience, you might want
to give a little thought to the following puzzles:

 - How can we load an arbitrary number (e.g. an address constant) into
   a register? Note that the immediate value in something like "PUSH imm"
   must be printable.
   
 - Without the MOV instruction, how do we do loads and stores?
 
 - Without the INT instruction, how can we even exit the program?
 
 - How do we implement bitwise OR with the given instructions?
 
 - The Jcc (e.g. JNZ, JAE) instructions take only an absolute displacement.
   How do we do function (pointer) calls and returns?
   
 - The displacement must be printable, which means it is always a
   positive number. How do we even do loops?

I will  explain those problems and  my solutions in later  sections; I
think they  are each interesting.  (If you are  not going to  read the
whole paper, which is likely, I think "18. Loops" and "17. Exiting and
initializing  the  program"  are the  most  interesting/funny  hacks.)
Various parts of  the compiler's design are intertwined  with the many
constraints, so there is no easy path through the whole idea. For now,
let's warm up with the file format.


    ** 6. Executable file formats **

In order for the compiler's output to be executable, it needs to be in a
file that  the operating system  recognizes as program. This  means that
the header  of the program  needs to be printable  too. We can  rule out
several formats that cannot possibly have printable headers:

On Linux,  executables are ELF files.  The first byte of  these files is
always 0x7F "DELETE", which is not printable. Several other bytes in the
header have to be zero.

On MacOS,  executables are Mach-O  files. These files always  start with
0xFEEDFACE, an  amusing example  of unprintable bytes  whose hexadecimal
representation nonetheless  spells out words.  It also requires  a field
called MH_EXECUTE to be 0x02, among other problems.

On Windows, most  executables are EXE Files. The modern  version of this
format is called Portable Executable (PE) and is used for 32- and 64-bit
programs. It contains a required COFF subheader which always starts with
0x50450000 (the zero bytes not printable). For backward "compatibility",
PE  EXE files  actually  start  with old-style  EXE  headers, which  are
actually programs that print something like

   This program cannot be run in DOS mode.

and then exit. Windows recognizes a  secret code that tells it to ignore
that part and look at the *real* program.

...  this eliminates  the main  executable  formats for  the modern  x86
platforms. :( We  saw that the EICAR  program is a COM  file, so clearly
that is a possibility?

A DOS .COM file has no header.  The entire program is just inserted into
memory  at  the  address  0x0100  and  starts  running.  This  level  of
simplicity is a dream for a SIGBOVIK Compiler Author, but it has a fatal
flaw. In  order to understand,  we need to take  a break and  talk about
segmentation!


    ** 7. Segmentation break! **

DOS is  a 16-bit operating system,  and a 16-bit number  can only denote
65,536 ("64k") different values. To  allow programs to address more than
64k of  memory, Intel introduced "segments"  into the 8086. These  are a
nightmare  for programmers,  and when  I was  a teenager  and the  "flat
memory model" (32-bit  virtual addresses) became available,  I thought I
would be  free of  segments forever. We're  back! Roughly  speaking, the
instruction set allows you to supply 16-bit addresses (offsets), but the
processor  internally   combines  these   with  16-bit   base  addresses
(segments). The "real address" is (segment * 16 + offset). Some annoying
facts:

 - The segment registers are changed through different instructions than
   the regular registers. None are available in printable X86.
   
 - However, we can make some instructions use a different segment
   register with one of the prefix bytes (e.g. 0x36 makes the next
   instruction use the SS (stack) segment instead of the default, which
   might be DS (data)).
   
 - However, some other instructions like PUSH or OUTS can only use a
   specific segment.
   
 - There are multiple different SEG:OFF pairs that reference the same
   real address.
   
 - The segment values are not predictable in DOS, because they depend
   on where DOS happens to place your program.

We'll have  to deal with segments  for sure, but one  consolation (?) is
that since we can't change the  values, the program will only access the
64k of data within the segments it starts out with.

There  are 6  segments,  CS (code),  DS (data),  SS  (stack), and  three
"other" segments ES, FS, and GS.


    ** 8. Executable file formats, continued... **

In a DOS .COM  file, CS, DS, ES, and SS are all  initialized to the same
value. This is  easy to think about,  but it causes a  super bad problem
for us: The  machine stack is inside  the same segment as  our code. The
machine stack is  a region of memory that the  PUSH and POP instructions
use (among  others); it  starts at  the end of  this single  segment and
grows   downward  (towards   lower   addresses,   where  the   program's
instructions are). If the stack collides  with the program, then it will
mess  up the  instructions  (which might  be an  effective  way to  make
self-modifying code, but we don't want to cheat). Most COM programs stay
out of  the way of the  stack by being  much smaller than 64k.  For good
reasons that I will explain later,  in this project, execution will need
to span the entire code segment. It might be possible to avoid using the
stack in  our programs, but  DOS interrupts (Section 17)  are constantly
happening  as our  program runs.  These  interrupts use  the stack,  and
although they put  the stack pointer back where it  was and don't modify
anything currently on the stack, the  values that they PUSH and then POP
are still  present in memory,  overwriting whatever was there.  We don't
have any  way to  turn these  off, because  the CLI  instruction ("clear
interrupts") is  0xFA, which is not  printable. It seems COM  files will
not work for this project.

This leaves old-style  16-bit DOS EXE files, which do  just barely work,
and this is  what ABC produces. EXE files afford  much more flexibility,
such as  the ability to access  up to 640kb (barring  tricks) of memory.
They also have many features that we  do not need or want. An EXE header
looks like this:

  offset  field                        ABC's value          ASCII
                                       (little-endian)
      00  magic number                 0x5A 0x4D             ZM
      02  extrabytes                   0x7E 0x7E             ~~
      04  pages in file                0x20 0x23              #
      06  relocation entries           0x20 0x20
      08  paragraphs in header         0x20 0x20
      10  minimum memory               0x20 0x20
      12  maximum memory               0x20 0x20
      14  initial stack segment        0x50 0x52             PR
      16  initial stack pointer        0x69 0x6e             in
      18  checksum                     0x74 0x79             ty
      20  initial ins pointer          (program dependent)
      22  code segment displacement    0x20 0x20
      24  relocation table start       0x20 0x20
      26  overlay number               0x43 0x20             C 

Normally, the  header is followed by  the relocation table (if  any; see
below) and  then the program  image. The program  image is some  blob of
data that gets placed contiguously in  memory, with the data segment set
to its  beginning and the  code and stack  segments set to  wherever the
header  asks. A  typical layout  would look  like this,  with the  solid
box being the contents of the EXE file:

                 DS,ES    CS       SS
                 |        |        |      (additional memory)
   (not in mem)  v        v        v
   +-----------+-----------------------+ - - - - - - - - - - - +
   |hdr| reloc | program image         |                       :
   |   |       |                       |                       :
   +-----------+-----------------------+ - - - - - - - - - - - +
    NOTVIRUS.EXE .......

All  of the  values  in  the header  are  printable,  which causes  some
difficulty. The problem stems from the fact that we must use values that
are  much larger  than is  reasonable for  several fields;  the smallest
16-bit printable  number is  0x2020, which is  8224. Several  fields are
measured in 16-byte "paragraphs" or 512-byte "pages" (anticipating their
use in printable  executables!), so these values can quickly  get out of
hand. Naive values cause the  program's effective memory requirements to
be too  large, and  DOS does  not load our  program. Nonetheless,  it is
possible. The  gory details of  the solution are documented  in exe.sml,
but the crux of the solution involves the following tricks:

  - Overflow the "pages in file" (a page is 512 bytes, so 0x2320 is 4MB;
    way beyond the 1MB limit) field to provide a smaller effective value.
    The file still needs to be pretty big.
    
  - Specify a much larger than usual "pages in header" (0x2020 * 16 =
    131kb). Since the header isn't loaded into memory, it doesn't count
    against the program's memory needs. A really big header also gives
    us space to store the paper. You're looking at part of the "header"
    right now.
    
  - Give technically invalid values for some fields (extrabytes, checksum,
    overlay number); DOS doesn't actually seem to care about these.
    This helps us get a paper title that's almost readable.

The layout of a compiled program is roughly like this:

                              DS,ES    CS       SS
                              |        |        |      (additional memory)
   (not in memory)            v        v        v
   +--------------------------+-----------------------+ - - - - - - 
   |hdr|paper| reloc | paper  |   program image       |             ...
   |   |intro|       |        |   paper   paper  paper|         
   +--------------------------+-----------------------+ - - - - - - 
    PAPER.EXE .......

This results in  an file size of  409,600 bytes, which I  believe is the
smallest possible.  At 160x128 characters  per page, this is  exactly 20
pages. Since we  can't change the segment registers, the  active part of
our program  is only the 64kb  data, code and stack  segments, and since
the stack segment  is somewhat unreliable (as described  above), we only
put stuff  in the data  and code  segments. As a  result, we need  to be
thoughtful about code size; this will be a challenge.

It's not necessary to understand this diagram since you are looking at a
1:1 scale  model right now, i.e.,  the program itself. I'll  point these
sections out as we encounter them.


    ** 9. The Program Segment Prefix **

The Program Segment Prefix, or PSP, is 256-bytes at the beginning of the
data segment. Depending on how you look at it, DOS either overwrites the
first 256  bytes of our  program image, or  the program image  is loaded
right after it,  but starts at address DS:0x0100  rather than DS:0x0000.
In any case,  we get this for free  whether we want it or  not, for both
COM and EXE files. Since this is  just part of DS, programs will be able
to read and  write the data there.  The most useful thing we  get is the
command line that the program is invoked with from the DOS prompt.


    ** 10. Relocations **

You already saw  the header structure (it's the title  of the paper) and
the relocation table (the full page of "~~Q("). For normal programs, the
purpose of the relocation table is for  DOS to patch the program so that
it can know where it's located in  memory; each time a program is loaded
it might be placed in a different  spot. When the program is loaded, DOS
goes through  all of the entries  in the relocation table,  and modifies
the given location in the program by adding the base segment to the word
at  that location.  Usually  this  location is  part  of an  instruction
sequence like "PUSH imm;  POP DS", where imm is some  value that we want
to be  relative to the program's  base segment. We can't  change segment
values, so the relocation table is  useless to us. In fact it's harmful,
because we have to have 8,224 (0x2020) relocation table entries in order
to have a  printable header, and whatever offsets are  in there will get
corrupted when the  program is loaded. We repeat the  same location over
and over, and  choose a location that's right after  the code segment in
memory, a part of the image we  don't need. I'll point out the spot that
gets  overwritten  when  we  get  there.  The  locations  are  given  as
segment:offset pairs,  which is  nice because we  have multiple  ways to
reference a given location. We simply solve for some segment:offset such
that (segment  * 16  + offset =  addr) and both  segment and  offset are
printable.


    ** 11. Addressing modes, temporaries, calling convention **

In  any  compiler,  one  must  decide on  various  conventions  for  how
variables  are laid  out in  memory, how  registers and  temporaries are
used, how arguments  are passed to functions, and so  on. There are lots
of  such  decision in  ABC;  some  are  basically  normal and  some  are
particular to the weird problems we have to solve. Let's talk about some
of  the limitations  of  the instruction  set that  we  have access  to,
because those inform the low-level design.

In Figure 1, there are several instructions that look like this:

    AND reg|mod/rm

These are each a family of instructions like

    AND AX <- BX
    AND BX <- [BP+SI+4]
    AND [12345] <- DI

where the source  (on the right) and destination are  given by some bits
in the  instruction's encoding.  The instruction  always acts  between a
register and a  "mod/rm", with two adjacent  opcodes determining whether
this is  of the form  "AND reg  <- mod/rm" or  "AND mod/rm <-  reg". The
mod/rm can  be one of  many possible values; here  is a table  which you
need not absorb:

  r8(/r)                            AL  CL  DL  BL  AH  CH  DH  BH
  r16(/r)                           AX  CX  DX  BX  SP  BP  SI  DI
  r32(/r)                           EAX ECX EDX EBX ESP EBP ESI EDI
  (In decimal) /digit (Opcode)        0   1   2   3   4   5   6   7
  (In binary) REG =                 000 001 010 011 100 101 110 111
  Effective Address      Mod  R/M   Value of ModR/M Byte (in Hex)
  [EAX]                   00  000   00  08  10  18 *20 *28 *30 *38
  [ECX]                       001   01 ?09  11  19 *21 *29 *31 *39
  [EDX]                       010   02 ?0A  12  1A *22 *2A *32 *3A
  [EBX]                       011   03  0B  13  1B *23 *2B *33 *3B
  [sib]                       100   04  0C  14  1C *24 *2C *34 *3C
  disp32                      101   05 ?0D  15  1D *25 *2D *35 *3D
  [ESI]                       110   06  0E  16  1E *26 *2E *36 *3E
  [EDI]                       111   07  0F  17  1F *27 *2F *37 *3F
  [EAX+disp8]             01  000  *40 *48 *50 *58 *60 *68 *70 *78
  [ECX+disp8]                 001  *41 *49 *51 *59 *61 *69 *71 *79
  [EDX+disp8]                 010  *42 *4A *52 *5A *62 *6A *72 *7A
  [EBX+disp8]                 011  *43 *4B *53 *5B *63 *6B *73 *7B
  [sib+disp8]                 100  *44 *4C *54 *5C *64 *6C *74 *7C
  [EBP+disp8]                 101  *45 *4D *55 *5D *65 *6D *75 *7D
  [ESI+disp8]                 110  *46 *4E *56 *5E *66 *6E *76 *7E
  [EDI+disp8]                 111  *47 *4F *57 *5F *67 *6F *77  7F
  [EAX+disp32]            10  000   80  88  90  98  A0  A8  B0  B8
  [ECX+disp32]                001   81  89  91  99  A1  A9  B1  B9
  [EDX+disp32]                010   82  8A  92  9A  A2  AA  B2  BA
  [EBX+disp32]                011   83  8B  93  9B  A3  AB  B3  BB
  [sib+disp32]                100   84  8C  94  9C  A4  AC  B4  BC
  [EBP+disp32]                101   85  8D  95  9D  A5  AD  B5  BD
  [ESI+disp32]                110   86  8E  96  9E  A6  AE  B6  BE
  [EDI+disp32]                111   87  8F  97  9F  A7  AF  B7  BF
  AL/AX/EAX               11  000   C0  C8  D0  D8  E0  E8  F0  F8
  CL/CX/ECX                   001   C1  C9  D1  D9  E1  E9  F1  F9
  DL/DX/EDX                   010   C2  CA  D2  DA  E2  EA  F2  FA
  BL/BX/EBX                   011   C3  CB  D3  DB  E3  EB  F3  FB
  AH/SP/ESP                   100   C4  CC  D4  DC  E4  EC  F4  FC
  CH/BP/EBP                   101   C5  CD  D5  DD  E5  ED  F5  FD
  DH/SI/ESI                   110   C6  CE  D6  DE  E6  EE  F6  FE
  BH/DI/EDI                   111   C7  CF  D7  DF  E7  EF  F7  FF

     Figure 2. Addressing modes

The "scaled index byte" (sib) has  another table with 224 entries, which
we won't get  into. There is also  a similar, but crazier,  table for 16
bit addresses and 8  bit operands. Note that only part  of this table is
printable  (marked with  *), which  means we  can only  use a  subset of
addressing modes. Notably:

 - We can't do any register-to-register operations, like "AND AX <- BX".
   Most compilers use these instructions frequently!
   
 - As a result, exactly one of the source or destination operand is
   some location in memory.
   
 - The simple addressing modes can only be paired with some registers.
   For example, AND DI <- [EDX] is allowed, but AND AX <- [EDX] is not.
   [ESI] means the memory in the location pointed to by the value in
   the ESI register.

This is even more annoying than x86 usually is. That said, the fact that
we  don't  have  register-to-register  operations  means  that  register
allocation is  far less important than  usual. Instead, we operate  on a
set  of temporaries,  accessed  using the  [EBP]+disp8 addressing  mode.
EBP's default segment is SS, so these temporaries are stored in the same
segment as  the stack. In fact,  since we initialized the  stack pointer
towards the  middle of  SS (it  has to be  printable; the  maximum value
would be 0x7e7e, but we use 0x6e69  to make the title more readable), we
have the entire region from that  to 0xFFFF to use for temporaries. Each
function frame (see below) has its own set of temporaries.

To perform a basic subtraction operation, whereas a traditional compiler
is likely to emit an instruction like

   0x29 0xC2    SUB AX <- DX          ;; AX = AX - DX
   
ABC emits a sequence like

   ??                     MOV AX <- [EBP+0x22]    ;; AX = tmp2
   0x67 0x29 0x45 0x20    SUB [EBP+0x20] <- AX    ;; tmp0 = tmp0 - AX

which is not so  bad. (Note that we do not have  a MOV instruction; this
puzzle is solved below). We often need to do much more work than this to
perform a  basic operation,  and optimization is  meaningful (especially
things that reduce code size).

The [EBP+disp8]  addressing mode denotes  the location in memory  at the
address in EBP,  plus the given 8-bit value (above,  0x22). Note that to
encode  this mod/rm,  we  need to  write the  displacement  byte in  the
opcode,  so  it must  be  printable.  The  EBP register  will  therefore
actually  always point  32 bytes  before  the first  temporary, so  that
temporary 0 is accessed as [EBP+0x20].

With this idea in mind, here is a summary of ABC's low-level design:

 - A C pointer is represented as a 16-bit address into the data segment.
 
 - Anything addressable therefore needs to be stored in DS. This includes
   global variables, local variables and function arguments.

 - Global variables are just allocated at compile time to some locations
   near the beginning of DS.
   
 - A traditional C compiler uses the machine stack to store local
   variables, but since these need to be in DS, not SS, we maintain a
   separate stack of arguments and locals in DS, which starts after the
   global variables and grows towards larger addresses. This is called the
   locals stack. The register EBX points 32 bytes before the locals stack,
   so that we can use [EBX+disp8] to efficiently access locals.
   
 - EBP always points 32 bytes before the "temp stack".
 
 - Both stacks (and the machine stack) advance when we make a function
   call, so that the values of locals and temporaries persist across the
   function call. ABC only stores the return address on the machine stack.
   
 - Aside from EBX, EBP, and ESP (the machine stack pointer), all other
   registers can be used for any purpose.

Next, we need to implement a number of low-level primitives that let our
program do computation. Let's warm up with something very basic.


    ** 12. Putting a value in a register **

When programming X86 like a normal person,  a very common task is to put
an arbitrary  number (for example, the  address of a global,  or a value
that appears in the user's program) into a register, like

    0xB8 0x34 0x12      MOV AX <- 0x1234

We don't have  this instruction available, since its opcode  0xB8 is not
printable. Moreover,  we need to be  able to load arbitrary  values, not
just printable ones (but the value is part of the instruction encoding).

We do have some ability to load values. For example, we can encode

                        AND AX <- 0x2020

since 0x2020 is printable. This clears most of the bits in AX, and then

                        AND AX <- 0x4040

will always  clear the remainder,  since (0x40 &  0x20 = 0x00).  With AX
containing 0x0000,  we could then repeat  "INC AX" 1,234 times  to reach
the desired value. This totally sucks, but it works.

There are  often more  direct routes. We  can XOR and  SUB and  AND with
printable 8-  or 16-bit  immediate values  in addition  to INC  and DEC.
There is probably no "closed form"  solution for the quickest route to a
given value (the presence  of both XOR and SUB makes  this rather like a
cryptographic function), but we can use computers to help.

We build a routine that generates a series of x86 instructions that load
a 16-bit value into  AX. In the general case, we do  this by loading two
8-bit values and  jamming them into AX  using a gross trick.  To load an
arbitrary value into AL  (the low byte of AX), ABC uses  a table that it
creates upon  startup. This table is  of size 256x256, and  gives us the
shortest (known) sequence  for putting some desired byte DST  in AL when
AL is  known to already contain  some byte SRC. This  table is populated
via something  like Dijkstra's "shortest path"  algorithm. For starters,
the diagonal  (SRC = DST)  can be  initialized to the  empty instruction
list. We  can then use INC  and DEC to fill  the rest of the  table with
very inefficient but correct sequences (still,  when SRC is 5 and DST is
6, INC AX will remain the best  approach!). Next, we maintain a queue of
cells that should  be searched (everything goes on the  queue except the
diagonal, which is already optimal). We repeatedly remove items from the
queue and  then explore what cells  we can reach from  that source byte.
For  example, if  we  pull out  the cell  (SRC=0x80,  DST=0x01), we  try
applying XOR,  SUB, and AND  (with printable immediate values),  etc. to
the source value 0x80 to see what we get. One such result is that we can
get AL=0x00 by doing AND AL  <- 0x40. Consulting the cell for (SRC=0x00,
DST=0x01), we see that  it contains a sequence of length  1 (INC AX), so
this  gives us a  new best  solution  by concatenating  these two  paths
(AND AL <- 0x40, INC AX), which is much better than (DEC AX, DEC AX, ...
79 times). We iterate this procedure until paths stop improving.

This works  well, with  only an  average of  2.54 bytes  of instructions
needed to  transform a source  byte into  a destination one  (across all
possible src/dst pairs). No sequence is  longer than 4 bytes. Since this
table is big  and programmatically computed when the  compiler starts, I
took  some trouble  to optimize  it  (the naive  implementation took  13
seconds, which  is a  bit of  an annoying  wait every  time you  run the
compiler!). There  were a few tricks,  but the most fruitful  one was to
functorize the  code that encodes  x86 instructions. This  code normally
works with vectors, and then the test above for the shortest instruction
sequence  would use  Word8Vector.size to  compute the  best one.  In the
functorized  version, the  type of  vector is  an abstract  argument. We
instantiate a size-only version of  encoding where the "vector of bytes"
is actually  just the count of  bytes, and concatenation is  just +. The
MLTon compiler is  then excellent at optimizing this code  to throw away
the  computations of  the byte  values (they  are dead),  and this  code
becomes plenty fast (~800 ms).

The table  of instructions contains  interesting structure, or  at least
pretty structure. Since  it is 256x256, it can't fit  in this paper 1:1,
but  I cropped  to  the prettiest  part, the  leftmost  160 columns.  It
appears as two  full pages in the  data segment (Pages 8 and  9) as some
cool  ASCII  triangles. In  this  graphic,  a  space character  means  0
instructions (this is only the diagonal of course, mainly visible on the
first page); '.' means one instruction  byte (just INC and DEC, near the
diagonal); '-'  is two instruction bytes  (like XOR AL <-  0x2A); '%' is
three;  and '#"  is  four.  This fractal  pattern  (like the  Sierpinski
triangle?)  shows up  all over  the  place in  mathematics and  computer
science and Hyrule. For example it  is reminiscent of the matrix of game
configurations in k/n Power Hours [KNPH'14].


Once we can load  an arbitrary byte into AL, we can fill  all of AX with
this trick. Suppose that our goal is  to load AH=0x12 and AL=0x34. If we
don't know anything about AX, we  can zero it with two AND instructions.
Then we can  emit the instructions to load 0x12  starting from the known
value 0x00. Then this sequence:

   instruction    AH  AL        stack           (ww, xx, yy, zz stand for
                  ww  0x12      xx yy zz ...          some arbitrary junk)
   PUSH AX            
                  ww  0x12      0x12 ww xx yy zz ...   
   PUSH 0x3040        
                  ww  0x12      0x40 0x30 0x12 ww xx yy zz ...
   INC SP             
                  ww  0x12      0x30 0x12 ww xx yy zz ...
   POP AX             
                0x12  0x30      ww xx yy zz ...
   INC SP             
                0x12  0x30      xx yy zz ...

Remember that x86 is  little endian, so the low byte goes  on the top of
the stack. This  trick places two words adjacent on  the stack, but then
misaligns the stack  by doing a manual  INC SP (and again at  the end to
clean  up). The  result is  that  AL gets  moved  into AH,  and a  known
printable value of our choice (0x30 above)  into AL. We can then use our
table  to transform  that  known value  to any  desired  value into  AL,
completing the 16-bit  value. This is reasonably brief  and only touches
the AX register, and we use it all the time in the generated code.


    ** 13. Moving between registers and memory **

Another useful kind of instruction is  MOV AX <- [EBP+0x20], which moves
the 16-bit word at the address in  EBP (offset by 0x20) into AX. This is
how  we read  and  write temporaries;  the "AX  <-  [EBP+0x20]" part  is
printable,  but  we   don't  have  the  MOV   opcode  available  (0x89).
Fortunately, the XOR instruction  is "information-preserving," so it can
be  used like  a  MOV. Specifically,  if  we already  have  zero in  the
destination, then XOR *is* a MOV. In order to load from memory we use an
instruction sequence like:

    ... various ...      set ax <- 0x0000        ;; using tricks above
  0x67 0x33 0x45 0x20    XOR AX <- [EBP+0x20]

To write to memory, we do:

  0x50                   PUSH AX                 ;; save value to write
    ... various ...      set ax <- 0x0000        ;; using tricks above
  0x67 0x21 0x45 0x20    AND [EBP+0x20] <- AX    ;; clears to zero
  0x58                   POP AX                  ;; restore value
  0x67 0x31 0x45 0x20    XOR [EBP+0x20] <- AX    ;; write it

This is almost... nice! But don't worry, it gets grosser.


    ** 14. Bitwise OR **

We  don't have  the OR  instruction, but  it can  be computed  with this
trick.

    1  1  0  0    A
    1  0  1  0    B

    1  0  0  0    A AND B
    0  1  1  0    A XOR B
    0  0  0  0    (A AND B) AND (A XOR B)
    1  1  1  0    (A AND B)  OR (A XOR B)    
    1  1  1  0    (A AND B)  +  (A XOR B)

    1  1  1  0    A  OR B

This is the  table of all possible  bit combinations that A  and B could
have; the OR operation  is of course only dependent on  the pair of bits
at each position.  First, observe (in your mind; it's  not in the table)
that A OR  B is the same as A  + B unless both bits are  1; only in that
case do we need to  do a carry. So we compute A AND B,  and A XOR B; the
OR of  these two is the  same as A  OR B (it  separates A OR B  into the
cases where both  bits in the input  were 1, and the  case where exactly
one was  1). Since the two  expressions never have  a 1 bit in  the same
position, we can compute their OR  with +, giving us the desired result.
Implementing plus is also a multi-step process, described next:


    ** 15. Keeping track of what's up with the accumulator **

The  ABC   backend  (tactics.sml)  generates  X86   for  some  low-level
primitives that operate  on temporaries, like "Add tmp1  <- tmp2". (This
is described in Section 21 when  discussing the phases of the compiler.)
Because it's expensive  to load constants into registers,  we go through
some trouble  to keep track  of the machine  state as we  generate code.
This allows us to make some opportunistic improvements. For example, the
actual SML code implementing Add on 16-bit numbers looks like this:

  fun add_tmp16 acc dst_tmp src_tmp : acc =
    let
      val acc = acc ++ AX
    in
      imm_ax16 acc (Word16.fromInt 0xFFFF) //
      XOR (S16, A <- EBP_TEMPORARY src_tmp) ??
      forget_reg16 M.EAX //
      INC AX ??
      forget_reg16 M.EAX //
      SUB (S16, EBP_TEMPORARY dst_tmp <~ A) -- AX
    end

The approach is  to XOR the source value with  0xFFFF and then increment
it by 1; this negates the value in two's complement. We can then use the
SUB operator, whose opcode is printable, to subtract that negated value,
which is the same as adding it. The "accumulator" (variable acc) lets us
manage  the steps.  Without getting  into tedious  details, "acc  ++ AX"
claims the register AX so that tactics  know not to clobber it; we later
return it  with "-- AX".  The imm_ax16  function loads the  value 0xFFFF
into AX;  this tactic  gets to  inspect what's  known about  the machine
state. For example,  if we happen to have just  assembled something that
left AX containing 0x0000 (very common) then we can simply DEC AX to get
0xFFFF in one  byte. imm_ax16 updates the accumulator to  record that AX
now contains 0xFFFF, as well as emitting whatever instructions it needs.
The // combinator emits a raw  instruction, and the ?? combinator allows
us  to learn  or forget  a fact  about a  register. Because  some tricks
require knowledge of e.g. AL but  not AH, the accumulator actually keeps
track of each  byte of each register independently.  It also understands
that if you claim  ESI, then SI cannot be used (SI is  part of ESI), and
so on. This is nice, and  the semi-monadic syntax allows what looks like
assembly code in  ML. (Also note the questionable <-  and <~ (hyphen vs.
tilde)  datatype constructors  that  distinguish the  two directions  of
instruction, "reg <-  mod/rm" vs. "mod/rm <~ reg".) The  biggest risk of
this approach is  if you don't accurately record the  state of registers
(e.g. you forget to "forget_reg16" after modifying it), because this can
lead to  tactics making  wrong assumptions but  only in  certain unlucky
situations. Some of my worst bugs were from this; it would be cleaner if
the accumulator  actually simulated the  instructions to update  its own
internal facts, rather than have the programmer make assertions.

Since the accumulator is purely functional, another cool thing we can do
is try out multiple different  strategies for assembling some block, and
pick  the best  one.  For example,  when we  decrease  EBP right  before
returning from a function (to  restore the caller's temporaries), we can
either  subtract a  constant (number  of  bytes depends  on the  machine
state) or DEC BP over and over (frequently faster).


    ** 16. Pointer loads and stores **

Another primitive we must implement is "Load16 dst_tmp <- addr_tmp"; the
temporary  addr_tmp contains  a 16-bit  address, and  we load  the value
contained at that address (in DS) and  store it in dst_tmp. This is used
for pointer dereferencing in the source C program, for example.

It's basically the same as loading from  a temporary; we just need to do
something like

    set DI <- 0             ;; macro
    XOR DI <- [EBP+0x20]    ;; appropriate addr temporary offset
    set SI <- 0             ;; macro
    XOR SI <- [DI]          ;; read from the address into SI
    set [EBP+0x24] <- 0     ;; appropriate dst temporary offset
    XOR [EBP+0x24] <- SI    ;; store it

(Again, the syntax [DI]  means use the contents of the  DI register as a
memory address, and  load from there. DI's default segment  is DS, which
is where  C pointers always  point.) The  only complication is  that the
pure-indirect mod/rm  bytes like  [DI] can only  be paired  with certain
registers or else they are not printable (Figure 2).

The reason to bring this primitive  up is that there's a delightful hack
that's possible if  the destination temporary and  address temporary are
the same slot.  This situation rarely occurs  naturalistically, since it
would correspond to unusual C code  like (int*)x = (int*)*x. However, it
is very commonly the output  of temporary coalescing (Section 22), since
it is typical for the final use of  an address to be a load from it. So,
this is actually useful (saves about  5% code size), but the main reason
to do it is awesomeness! Let's say the single temporary is at EBP+0x20.

    set DI <- 0             ;; macro
    XOR DI <- [EBP+0x20]    ;; load the address into DI.
    XOR DI <- [DI]          ;; DI = DI ^ *DI         (!?)
    XOR [EBP+0x20] <- DI    ;; tmp = address ^ address ^ value

The first two steps are reasonable, and put the address into DI. We want
to end  up with  the value  (whatever address points  to) in  the single
temporary. Next we  execute a crazy instruction, which  XORs the address
stored in DI with the value it points to. After this, DI contains addr ^
value, sort  of like  an encrypted  version of  the value.  However, the
temporary still  contains the address  (the "decryption key"), so  if we
XOR DI into  it, we get address ^  address ^ value, which is  0 ^ value,
which is just value! It's really nice how short the instruction sequence
is, and it only  uses a single register. The instruction  XOR DI <- [DI]
is so  weird--it probably occurs  in almost  no programs, because  it is
extremely rare for an absolute address to have any relationship with the
value  it  points  to. So  we  get  extra  style  points for  finding  a
legitimate use for it.

Stores are  the same  idea. The  trick actually  applies there  too, but
isn't useful because it doesn't save  us instructions, and because it is
uncommon for the address  and value to be the same  temporary in a store
operation (store is not really the  opposite of load in this sense; both
temporaries are read and neither is modified in
"Store16 addr_tmp <- src_tmp").


    ** 17. Exiting and initializing the program **

We also  want to be able  to exit the  program when we're done.  This is
normally done by  making a "system call" to an  operating system routine
to tell it that we're done and  the program can be unloaded. In DOS, you
make  system calls  by triggering  a  processor interrupt  with the  INT
instruction, which is a way of telling the operating system, "Check this
out!!" We don't  have access to this instruction, whose  opcode is 0xCD.
Alas!  The  INT  instruction  is  a  gateway  to  all  sorts  of  useful
functionality,  like printing  strings  and reading  from the  keyboard,
reading and writing files, changing video modes, and so on, so it's very
sad to go without it. (The  EICAR test virus uses self-modifying code to
create two INT  instructions; one is to print the  string and the second
is to exit.) In DOS, INT 0x21  is the most useful one; you set registers
to some values to access dozens of different functions.

INT 0x21  is so  common that  it appears in  the Program  Segment Prefix
that's always  loaded at the  beginning of  the data segment.  It's just
sitting there amidst some zeroes:

     ...
   DS:0x004A    0x00 0x00         ADD [BX+SI] <- AL
   DS:0x004C    0x00 0x00         ADD [BX+SI] <- AL
   DS:0x004E    0x00 0x00         ADD [BX+SI] <- AL
   DS:0x0050    0xCD 0x21         INT 0x21
   DS:0x0051    0xCB              RETF
   DS:0x004E    0x00 0x00         ADD [BX+SI] <- AL
   DS:0x004E    0x00 0x00         ADD [BX+SI] <- AL
     ...

It  even  tantalizingly  has  RETF   (far  return  from  function  call)
immediately after it,  like it was planted there by  some puzzlemaker of
years past, exactly  for this kind of situation. (I  don't actually know
why it's there!) RETF pops both  a return address and return segment, so
if we could manage  to put a return address on the  stack (not hard) and
the  code segment  (we don't  know  it, but  we could  probably use  the
relocation table  to write  it somewhere) beneath  it, and  then somehow
transfer control  to DS:0x0050, we'd  have a  fully general INT  0x21 to
use! It  would even help with  the loop problem (next  section) since it
lets us return  to an arbitrary address, and could  conceivably even let
us escape the confines of always  executing code within the initial code
segment CS (because RETF modifies CS). But speaking of confines, none of
this  will  work, because  we  have  no way  of  modifying  CS to  start
executing code out of DS. Too bad,  so sad. (This idea might pan out for
a  COM file  where  CS=DS, but  there  we have  no  relocation table  so
figuring out what  segment value to put in the  stack would require some
other hack. We  also have the Loop problem, preventing  us from reliably
jumping to DS:0x0050. Might be worth further exploration.)

Jumping  the  program to  a  non-printable  instruction  is also  a  bit
questionable, though  it's not  an instruction that  we wrote  there, so
this does not  violate our self-modifying code fatwa. Is  it wrong for a
waiter  to serve  the ovo  lacto  vegetarian with  vegetarian food  that
causes him to eat non-vegetarian  food that the customer himself brought
with him? Who can say?

This is  not hopeless. The way  interrupts actually work is  to stop the
current execution (saving  the state of the registers on  the stack) and
then consult  a table of  "interrupt vectors"  (in my opinion  the table
itself should be called the "interrupt vector", containing addresses) at
the address 0x0000:0x0000 (i.e., right at the beginning of memory). Each
interrupt  has a  number, and  each address  is a  32-bit segment:offset
pair. So the address at 4 * 0x21  = 0x0084 is the location of DOS's code
for  INT 0x21.  In 16-bit  real mode  programs, there's  nothing special
about the  operating system; you can  just jump directly into  it if you
want, or  overwrite it with  your own stuff. In  fact, this is  how many
viruses work;  for example by  replacing the  address for INT  0x21 with
their  own code,  and  intercepting file  operations  to insert  viruses
before  calling  through  to  the  original INT  0x21  handler  so  that
everything still works.

Fetching  the INT  0x21 address  is not  immediately useful,  because we
can't transfer  control to it;  we don't  have the CALL  instruction. In
fact, the only JMP instructions we have must jump a small fixed distance
forward (next section). But! The INT  instruction is not the only way to
trigger interrupts. The timer  interrupt is firing continuously, messing
with our stack, for example. We can modify the interrupt vector table to
make the timer  interrupt (INT 0x8) instead point to  the INT 0x21 code,
and then "wait"  for a timer interrupt to happen,  and maybe restore the
old timer interrupt code when we're  done. This might work, but it seems
extremely brittle.  (Also, the  timer interrupt  handler has  to perform
certain low-level  duties or else  the system will  freeze.) Fortunately
there's a better choice: The CPU  will also trigger an interrupt when an
illegal  instruction  is  executed.  Normally  the  illegal  instruction
handler would do something like  crash the program gracelessly (in Unix,
it sends the SIGILL  signal. Sadly there is no SIGBOVIK.)  Do we have an
illegal instruction inside printable x86? In fact we do!

   0x63    Adjust RPL Field of Segment Selector

... it's just  sitting in there, this totally weird  instruction with no
other possible uses amidst a bunch of sensible ones. This instruction is
for some operating system privilege stuff, and is illegal in real mode.

So, when we first start up an ABC program, one of the first things we do
is read the address of the  INT 0x21 handler at 0x0000:0x0084, and write
it  over the  INT 0x06  (illegal  instruction) handler.  Luckily the  FS
segment is set  to 0x0000 when our program starts  (we can't change it),
so  we  can use  the  FS  segment  override  instruction to  access  the
beginning of RAM.  Once we overwrite the address, then  whenever we want
we can set up argument registers for  the system call "exit" (AH = 0x4c,
AL = status  code), and execute the illegal ARPL  instruction. This will
trigger interrupt 0x06, which is now actually the INT 0x21 code, and DOS
will "cleanly" exit the program for us.

It is very tempting to use this trick to make other system calls through
INT 0x21,  or perhaps to  jump to  arbitrary addresses of  our choosing!
Sadly, there are two very serious issues:

 - When the processor triggers the illegal instruction interrupt, the
   return address that it pushes on the stack is the address of the
   illegal instruction itself, not the one that follows it. So when the
   interrupt handler returns, it simply executes another illegal
   instruction.
   
 - When the interrupt is triggered, it clears the interrupt flag (so
   that for example the timer interrupt doesn't fire while it's already
   running). Only a few instructions, which we don't have access to,
   can restore the interrupt flag. This means that we would only be able
   to do this once, and after we did, many things would stop working
   because interrupts would stop firing.

Neither of these issues are a problem for the exit system call, since we
only do it once. YOEO!

The ARPL  instruction takes  two argument  bytes which  just have  to be
printable; the instruction we actually encode is

  0x63 0x79 0x61     ARPL [ECX+0x61] <- DI

The ASCII  sequence is  "cya", as  in see  ya, which  we follow  with an
unexecuted exclamation mark for emphasis. You can find the string "cya!"
in the code segment on page 16 if you're good at Where's Waldo stuff!


    ** 18. Loops **

The last major  problem involves control flow. In printable  x86 we have
available a family of instructions  Jcc+disp8. Jcc stands for "jump (on)
condition code", and consists of 15 opcodes:

 char   opcode                                     Also known as
   p     0x70    JO     Jump if overflow
   q     0x71    JNO    Jump not overflow
   r     0x72    JB     Jump below                 JNAE, JC
   s     0x73    JNB    Jump not below             JNB, JAE, NKC
   t     0x74    JZ     Jump zero                  JE
   u     0x75    JNZ    Jump not zero              JNE
   v     0x76    JBE    Jump below or equal        JNA
   w     0x77    JNBE   Jump not below or equal    JA
   x     0x78    JS     Jump if sign
   y     0x79    JNS    Jump not sign
   z     0x7A    JP     Jump if parity even        JPE
   {     0x7B    JNP    Jump if parity odd         JPO
   |     0x7C    JL     Jump less                  JNGE
   }     0x7D    JNL    Jump not less              JNL
   ~     0x7E    JLE    Jump if less or equal      JNG

This is  a fairly full  set of conditions  (although we are  missing the
last  one,  JNLE/JG, with  opcode  0x7F).  Each  of these  consults  the
processor's FLAGS register  and tests for a certain  condition. FLAGS is
updated on many operations; for example, the  "zero flag" ZF is set to 1
if the result of certain operations  is zero, such as if "SUB [EBP+0x24]
<- AX"  ends up writing 0x0000  into memory, and  ZF is cleared to  0 if
not. The JZ instruction jumps if ZF is set, and just continues on to the
next instruction otherwise.  JZ has an alias, JE (Jump  equal); they are
the same exact  opcode because when you subtract two  equal numbers, you
get  zero. Since  it is  common  to want  to set  the appropriate  FLAGS
without actually subtracting, the CMP  (compare) instruction is like SUB
but it only updates  flags. We have a version of  the CMP instruction in
printable x86, so all is well so far.

These  particular instructions  are Jcc+disp8,  so we  provide an  8-bit
displacement. The  address of the  current instruction is stored  in the
EIP  ("instruction  pointer") register.  When  EIP  points at  Jcc+disp8
instruction, EIP is set to  the instruction immediately after it (EIP+2)
and then  if we jump,  incremented further by  disp8. The disp8  byte is
treated as  signed, so jumps  can go upward or  downward. Unfortunately,
all   printable  displacements   are   positive!  This   allows  us   to
conditionally skip code, but only downward,  and only between 32 and 127
bytes.

This subset  won't even be  Turing-complete if we can't  jump backwards;
all  programs  will  terminate  because  the  instruction  pointer  only
increases.  What actually  happens when  we reach  the end  of the  code
segment? If EIP is 0xFFFF and  we execute a single-byte instruction like
INC AX, EIP just continues on  to 0x00010000; the EIP register is 32-bit
despite us struggling with 16-bit segments and offsets. This instruction
is right after  the code segment, and indeed  contains whatever followed
our code  segment in the  program image.  So we could  conceivably break
free of the  64k code segment. Unfortunately, performing a  jump when in
this weird  state still just jumps  downward, and the situation  is very
brittle (see Section XXX for some ideas and problems). However, there is
a  special case  on the  processor, probably  for compatibility  with an
earlier  processor;  it's  right  there   in  the  pseudocode  for  this
instruction in Intel's manual [INTC'01]:

  IF condition
     THEN
        EIP <- EIP + SignExtend(DEST)
        IF OperandSize = 16
           THEN
              EIP <- EIP AND 0000FFFFH;
        FI;                                          (sic -tom7)
           ELSE (* OperandSize = 32 *)
              IF EIP < CS.Base OR EIP > CS.Limit
                  #GP
        FI;
  FI;

Specifically, if we  are right at the  end of the code  segment, and our
jump's displacement takes us past the  end, then we "wrap around" to the
beginning, because EIP is bitwise-anded with 0xFFFF. This means that our
program can do one  backwards jump, from the end of  the segment back to
the beginning.


We're approaching  the data section  now, so  it's time to  take another
break! Here it is:
